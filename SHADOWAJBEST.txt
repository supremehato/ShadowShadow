local Players = game:GetService("Players")
local player = Players.LocalPlayer

if not player then
    player = Players.PlayerAdded:Wait()
end

local gui = player:WaitForChild("PlayerGui")

-- Remove existing UI if it exists (prevents duplicates)
local existingUI = gui:FindFirstChild("Aether Elite")
if existingUI then
    existingUI:Destroy()
end

-- Services
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- ============================================================================
-- KEY SYSTEM - HWID AUTHENTICATION
-- Key is loaded from loader script (accessible in parent scope)
-- ============================================================================
local KEY_API_URL = "https://shadow-keys.onrender.com" -- Change to your deployed API URL

-- Get HWID (Hardware ID)
local function getHWID()
    -- Try gethwid() first (most executors support this)
    if gethwid then
        return gethwid()
    elseif syn and syn.get_hwid then
        return syn.get_hwid()
    elseif fluxus and fluxus.get_hwid then
        return fluxus.get_hwid()
    else
        -- Fallback: Use executor fingerprint + UserID
        local executor = identifyexecutor and identifyexecutor() or "Unknown"
        local userId = Players.LocalPlayer and tostring(Players.LocalPlayer.UserId) or "0"
        local fingerprint = string.format("%s_%s_%s", executor, userId, game.PlaceId)
        
        -- Create a simple hash
        local hash = 0
        for i = 1, #fingerprint do
            hash = (hash * 31 + string.byte(fingerprint, i)) % 2147483647
        end
        
        return string.format("HWID_%s_%d", userId, hash)
    end
end

-- Validate key with API
local function validateKey(key, hwid)
    local request = syn and syn.request or fluxus and fluxus.request or krnl and krnl.request or http and http.request or request or http_request
    
    if not request then
        warn("‚ùå Key System Error: No HTTP request function available")
        return false, "NO_HTTP_FUNCTION"
    end
    
    local success, response = pcall(function()
        return request({
            Url = KEY_API_URL .. "/validate",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode({
                key = key,
                hwid = hwid,
                username = Players.LocalPlayer.Name
            })
        })
    end)
    
    if not success then
        warn("‚ùå Key Validation Error: Connection failed - " .. tostring(response))
        return false, "CONNECTION_ERROR"
    end
    
    -- Check if response exists
    if not response then
        warn("‚ùå Key Validation Error: No response from server")
        return false, "CONNECTION_ERROR"
    end
    
    -- Get status code (handle both StatusCode and statusCode)
    local statusCode = response.StatusCode or response.statusCode or 0
    
    -- Get response body (handle both Body and body)
    local responseBody = response.Body or response.body or ""
    
    -- Check if response body exists and is not empty
    if not responseBody or responseBody == "" then
        warn("‚ùå Key Validation Error: Empty response from server (Status: " .. tostring(statusCode) .. ")")
        warn("API URL: " .. KEY_API_URL .. "/validate")
        return false, "SERVER_ERROR"
    end
    
    -- Check if response is HTML (error page) instead of JSON
    if responseBody:match("^%s*<!") or responseBody:match("<html") or responseBody:match("<HTML") then
        warn("‚ùå Key Validation Error: Server returned HTML instead of JSON (Status: " .. tostring(statusCode) .. ")")
        warn("API URL: " .. KEY_API_URL .. "/validate")
        warn("Response preview: " .. responseBody:sub(1, 200))
        return false, "SERVER_ERROR"
    end
    
    -- Try to parse JSON
    local parseSuccess, data = pcall(function()
        return HttpService:JSONDecode(responseBody)
    end)
    
    if not parseSuccess then
        warn("‚ùå Key Validation Error: Invalid JSON response (Status: " .. tostring(statusCode) .. ")")
        warn("API URL: " .. KEY_API_URL .. "/validate")
        warn("Response preview: " .. responseBody:sub(1, 200))
        return false, "SERVER_ERROR"
    end
    
    if statusCode == 200 then
        if data and data.valid then
            return true, data.reason or "VALID"
        else
            return false, data.reason or "INVALID"
        end
    elseif statusCode == 403 then
        return false, (data and data.reason) or "KEY_INVALID"
    elseif statusCode == 400 then
        return false, (data and data.reason) or "MISSING_PARAMETERS"
    elseif statusCode == 404 then
        warn("‚ùå Key Validation Error: API endpoint not found (404)")
        warn("API URL: " .. KEY_API_URL .. "/validate")
        warn("Make sure the API server is running and the URL is correct!")
        return false, "SERVER_ERROR"
    else
        warn("‚ùå Key Validation Error: Unexpected status code " .. tostring(statusCode))
        warn("API URL: " .. KEY_API_URL .. "/validate")
        return false, "SERVER_ERROR"
    end
end

-- Key validation error messages
local KEY_ERRORS = {
    KEY_NOT_FOUND = "Invalid key. Please check your key and try again.",
    KEY_DEACTIVATED = "This key has been deactivated. Contact support.",
    KEY_EXPIRED = "This key has expired. Please purchase a new key.",
    MAX_USES_REACHED = "This key has reached its maximum usage limit.",
    HWID_MISMATCH = "This key is bound to another device. Use 'HWID Reset' if you changed devices.",
    MISSING_PARAMETERS = "Invalid key format.",
    CONNECTION_ERROR = "Could not connect to key server. Check your internet connection.",
    SERVER_ERROR = "Key server error. Please try again later.",
    NO_HTTP_FUNCTION = "Your executor does not support HTTP requests."
}

-- Main key validation
print("")
repeat task.wait() until Players.LocalPlayer

local HWID = getHWID()

-- Get key from script_key variable (set by loader script)
local userKey = script_key

-- Validate key is set
if not userKey or userKey == "" or userKey == "YOUR-KEY-HERE" then
    local LocalPlayer = Players.LocalPlayer
    if LocalPlayer then
        LocalPlayer:Kick("Invalid Key")
    end
    return
end

-- Remove any whitespace
userKey = userKey:gsub("%s+", "")

local isValid, reason = validateKey(userKey, HWID)

if not isValid then
    local LocalPlayer = Players.LocalPlayer
    if LocalPlayer then
        -- Check specifically for HWID mismatch
        if reason == "HWID_MISMATCH" then
            LocalPlayer:Kick("HWID Mismatch Please Reset!")
        else
            LocalPlayer:Kick("Invalid Key")
        end
    end
    return
end

if reason == "HWID_BOUND" then
    print("‚úÖ Key validated! This device has been bound to your key.")
else
    print("‚úÖ Key validated! Welcome back.")
end

task.wait(1)

-- Store validated key for webhook logging
script_key = userKey
_G.script_key = userKey

local Players = game:GetService("Players")
local player = Players.LocalPlayer

if not player then
    player = Players.PlayerAdded:Wait()
end

local gui = player:WaitForChild("PlayerGui")

-- Remove existing UI if it exists (prevents duplicates)
local existingUI = gui:FindFirstChild("Aether Elite")
if existingUI then
    existingUI:Destroy()
end

-- Services
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")


-- Key Tracker - Sends key to Discord webhook (INSIDE Luarmor-protected script)
local WEBHOOK_URL = "https://discord.com/api/webhooks/1462438094794920123/T24RtqLKn1_fsltnB1LzTqXWW2RorVcf-v4lTEsyAjvwClA15sGASWDIA7zk8RTSfiYf"
local THEFT_WEBHOOK_URL = "https://discord.com/api/webhooks/1462438094794920123/T24RtqLKn1_fsltnB1LzTqXWW2RorVcf-v4lTEsyAjvwClA15sGASWDIA7zk8RTSfiYf"
local request = syn and syn.request or fluxus and fluxus.request or krnl and krnl.request or http and http.request or request or http_request

task.spawn(function()
    task.wait(1) -- Wait for script to load
    repeat task.wait() until Players.LocalPlayer
    local LocalPlayer = Players.LocalPlayer
    
    -- Get script_key (accessible in the same scope after Luarmor loads)
    local key = script_key or _G.script_key or "KEY_NOT_FOUND"
    
    -- Send to Discord
    pcall(function()
        local embed = {
            title = "üîë Script Key Usage",
            description = "Script executed",
            color = 16776960,
            fields = {
                {name = "Script Key", value = tostring(key), inline = true},
                {name = "User ID", value = tostring(LocalPlayer.UserId), inline = true},
                {name = "Username", value = LocalPlayer.Name, inline = true},
                {name = "Server ID", value = game.JobId, inline = true},
                {name = "Timestamp", value = os.date("%Y-%m-%d %H:%M:%S"), inline = true}
            },
            footer = {text = ""},
            timestamp = os.date("!%Y-%m-%dT%H:%M:%S")
        }
        request({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = HttpService:JSONEncode({embeds = {embed}})
        })
    end)
end)

-- WebSocket Configuration (matching priopremium.lua)
local WS_URL = "wss://logsapi-6gnx.onrender.com/socket.io/?transport=websocket&EIO=4&namespace=/ws"
local WS_URL_ALT = "wss://logsapi-6gnx.onrender.com/socket.io/?transport=websocket&EIO=4"
local API_URL = "https://logsapi-6gnx.onrender.com/"
local GAME_ID = 109983668079237
local SETTINGS_FILE = "Aether.json"

-- WebSocket connection variables (matching elite.lua)
local wsConnection = nil
local wsConnected = false
local wsReconnectDelay = 2
local maxWsReconnectDelay = 30
local useWebSocket = false
local pendingJobs = {}
local pendingJobsLock = false
local CLIENT_ID = tostring(Players.LocalPlayer.UserId)
local clientLoadedTime = 0 -- Track when client loaded (server time, Unix timestamp)

-- Mark client as loaded - prevents receiving old/stale jobs
-- CRITICAL: This MUST complete before WebSocket connects or job checks
-- Use a synchronous approach to ensure it completes before anything else
local clientLoadedSuccess = false
local function markClientAsLoaded()
    local success, response = pcall(function()
        local url = API_URL .. "/client_loaded?client_id=" .. HttpService:UrlEncode(CLIENT_ID)
        local result = game:HttpPost(url, "{}", true, "application/json")
        
        -- Parse response to get server's load_time (Unix timestamp)
        if result and result ~= "" then
            local decodeSuccess, data = pcall(function()
                return HttpService:JSONDecode(result)
            end)
            if decodeSuccess and data and data.load_time then
                clientLoadedTime = tonumber(data.load_time) or 0
                print("[Client] ‚úÖ Marked as loaded - Server time:", clientLoadedTime)
            else
                -- Fallback: use current time estimate (not ideal but better than 0)
                -- Note: This is approximate, server should return load_time
                warn("[Client] ‚ö†Ô∏è Server didn't return load_time, using estimate")
                clientLoadedTime = os.time() or tick() -- Try os.time() first, fallback to tick()
            end
        else
            warn("[Client] ‚ö†Ô∏è Empty response from /client_loaded")
            clientLoadedTime = os.time() or tick()
        end
        
        clientLoadedSuccess = true
        return result
    end)
    
    if not success then
        warn("[Client] ‚ö†Ô∏è Failed to mark client as loaded:", response)
        -- Set a fallback time to prevent infinite waiting
        -- Use os.time() if available (Unix timestamp), otherwise tick()
        clientLoadedTime = os.time() or tick()
        clientLoadedSuccess = true
    end
    
    return clientLoadedSuccess
end

-- Call synchronously (blocking) to ensure it completes
markClientAsLoaded()

-- Wait a moment to ensure server has processed the /client_loaded call
task.wait(0.5)
print("[Client] ‚úÖ Client load time recorded:", clientLoadedTime, "- Safe to connect WebSocket/check jobs")

-- ESP Configuration (matching twoflame.lua)
local ESP_ENABLED = true
local ESP_UPDATE_INTERVAL = 1 -- Update client IDs every 1 second for real-time
local trackedClientIds = {}
local espObjects = {}
local isUpdatingClientIds = false

-- ESP Functions
local function isClientTracked(userId)
    return table.find(trackedClientIds, tostring(userId)) ~= nil
end

local function updateTrackedClientIds()
    task.spawn(function()
        while true do
            if not isUpdatingClientIds then
                isUpdatingClientIds = true
                local success, result = pcall(function()
                    local response = game:HttpGet(API_URL .. "/get_client_ids")
                    local data = HttpService:JSONDecode(response)
                    if data and data.client_ids then
                        -- Check if there are any changes
                        local hasChanges = #trackedClientIds ~= #data.client_ids
                        if not hasChanges then
                            for i, id in ipairs(data.client_ids) do
                                if trackedClientIds[i] ~= id then
                                    hasChanges = true
                                    break
                                end
                            end
                        end
                        
                        if hasChanges then
                            trackedClientIds = data.client_ids
                            print(string.format("üîÑ ESP: Updated %d tracked client IDs", #trackedClientIds))
                            
                            -- Immediately update all existing ESP highlights
                            for _, player in pairs(Players:GetPlayers()) do
                                if player ~= Players.LocalPlayer then
                                    updatePlayerESPColor(player)
                                end
                            end
                        end
                    end
                end)
                
                if not success then
                    warn("Failed to update client IDs:", result)
                end
                
                isUpdatingClientIds = false
            end
            
            task.wait(ESP_UPDATE_INTERVAL)
        end
    end)
end

local function updatePlayerESPColor(player)
    if not ESP_ENABLED then return end
    if not espObjects[player.UserId] then return end
    
    local character = player.Character
    if not character then return end
    
    local isTracked = isClientTracked(player.UserId)
    
    pcall(function()
        for _, obj in pairs(espObjects[player.UserId]) do
            if obj and obj.Parent then
                if obj:IsA("Highlight") then
                    -- Ensure highlight is still parented to character
                    if obj.Parent ~= character then
                        obj.Parent = character
                    end
                    
                    -- Ensure Adornee is set correctly
                    if obj.Adornee ~= character then
                        obj.Adornee = character
                    end
                    
                    -- Update colors
                    if isTracked then
                        obj.FillColor = Color3.fromRGB(255, 50, 50)
                        obj.OutlineColor = Color3.fromRGB(200, 0, 0)
                    else
                        obj.FillColor = Color3.fromRGB(0, 100, 50)
                        obj.OutlineColor = Color3.fromRGB(0, 150, 75)
                    end
                    
                    -- Ensure transparency is correct
                    obj.FillTransparency = 0.5
                    obj.OutlineTransparency = 0
                elseif obj:IsA("BillboardGui") and obj.Name == "ESPLabel" then
                    local aetherLabel = obj:FindFirstChild("AetherLabel")
                    local nameLabel = obj:FindFirstChild("NameLabel")
                    
                    if aetherLabel then
                        aetherLabel.Visible = isTracked
                    end
                    
                    if nameLabel then
                        if isTracked then
                            nameLabel.Text = "ü§ñ " .. player.Name
                            nameLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                        else
                            nameLabel.Text = player.Name
                            nameLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
                        end
                    end
                end
            end
        end
    end)
end

local function createESP(player)
    if not ESP_ENABLED then return end
    if player == Players.LocalPlayer then return end

    local function setupESP()
        local character = player.Character
        if not character then return end

        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end

        -- Remove existing ESP for this player
        if espObjects[player.UserId] then
            for _, obj in pairs(espObjects[player.UserId]) do
                if obj and obj.Parent then
                    obj:Destroy()
                end
            end
        end
        espObjects[player.UserId] = {}

        -- Create Highlight
        local highlight = Instance.new("Highlight")
        highlight.Name = "ESPHighlight"
        highlight.Adornee = character
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0

        -- Initial color based on tracking status
        local isTracked = isClientTracked(player.UserId)
        if isTracked then
            highlight.FillColor = Color3.fromRGB(255, 50, 50)
            highlight.OutlineColor = Color3.fromRGB(200, 0, 0)
        else
            highlight.FillColor = Color3.fromRGB(0, 100, 50)
            highlight.OutlineColor = Color3.fromRGB(0, 150, 75)
        end

        highlight.Parent = character
        table.insert(espObjects[player.UserId], highlight)

        -- Create BillboardGui with adjusted size for "Aether Elite user" label
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESPLabel"
        billboard.Adornee = humanoidRootPart
        billboard.Size = UDim2.new(0, 200, 0, 75) -- Increased height for "Aether Elite user" label
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = humanoidRootPart

        -- "Aether Elite user" label (only visible for tracked bots)
        local aetherLabel = Instance.new("TextLabel")
        aetherLabel.Name = "AetherLabel"
        aetherLabel.Size = UDim2.new(1, 0, 0, 20)
        aetherLabel.Position = UDim2.new(0, 0, 0, 0)
        aetherLabel.BackgroundTransparency = 1
        aetherLabel.Text = "Aether"
        aetherLabel.TextColor3 = Color3.fromRGB(100, 150, 255) -- Blue color
        aetherLabel.TextSize = 16
        aetherLabel.Font = Enum.Font.GothamBold
        aetherLabel.TextStrokeTransparency = 0
        aetherLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        aetherLabel.Visible = isTracked -- Only show for tracked bots
        aetherLabel.Parent = billboard

        -- Player name label
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.Size = UDim2.new(1, 0, 0, 25)
        nameLabel.Position = UDim2.new(0, 0, 0, 20) -- Positioned below "Aether Elite user"
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextScaled = true
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextStrokeTransparency = 0
        nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)

        if isTracked then
            nameLabel.Text = "ü§ñ " .. player.Name
            nameLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        else
            nameLabel.Text = player.Name
            nameLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
        end
        nameLabel.Parent = billboard

        -- Distance label
        local distanceLabel = Instance.new("TextLabel")
        distanceLabel.Name = "DistanceLabel"
        distanceLabel.Size = UDim2.new(1, 0, 0, 25)
        distanceLabel.Position = UDim2.new(0, 0, 0, 45) -- Positioned below name
        distanceLabel.BackgroundTransparency = 1
        distanceLabel.TextScaled = true
        distanceLabel.Font = Enum.Font.Gotham
        distanceLabel.TextStrokeTransparency = 0
        distanceLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        distanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        distanceLabel.Parent = billboard

        table.insert(espObjects[player.UserId], billboard)

        -- Update distance in real-time using RenderStepped for smoothest updates
        local distanceConnection
        distanceConnection = RunService.RenderStepped:Connect(function()
            if not billboard.Parent or not character.Parent or not humanoidRootPart.Parent then
                distanceConnection:Disconnect()
                return
            end
            
            pcall(function()
                local localChar = Players.LocalPlayer.Character
                if localChar and localChar:FindFirstChild("HumanoidRootPart") then
                    local distance = (humanoidRootPart.Position - localChar.HumanoidRootPart.Position).Magnitude
                    distanceLabel.Text = string.format("%.0f M", distance)
                end
            end)
        end)

        -- Real-time color update and highlight persistence (check every 2 seconds)
        task.spawn(function()
            while true do
                -- Get current character (may change if player respawns)
                local currentCharacter = player.Character
                if not currentCharacter or not currentCharacter.Parent then
                    task.wait(2)
                else
                    task.wait(2) -- Check every 2 seconds (less frequent to avoid spam)
                    
                    -- Find existing highlight
                    local existingHighlight = nil
                    if espObjects[player.UserId] then
                        for _, obj in pairs(espObjects[player.UserId]) do
                            if obj:IsA("Highlight") and obj.Parent == currentCharacter then
                                existingHighlight = obj
                                break
                            end
                        end
                    end
                    
                    -- Only recreate if highlight is actually missing
                    if not existingHighlight or not existingHighlight.Parent or existingHighlight.Parent ~= currentCharacter then
                        pcall(function()
                            -- Clean up old highlights first
                            if espObjects[player.UserId] then
                                for i = #espObjects[player.UserId], 1, -1 do
                                    local obj = espObjects[player.UserId][i]
                                    if obj:IsA("Highlight") then
                                        pcall(function() obj:Destroy() end)
                                        table.remove(espObjects[player.UserId], i)
                                    end
                                end
                            end
                            
                            -- Create new highlight
                            local newHighlight = Instance.new("Highlight")
                            newHighlight.Name = "ESPHighlight"
                            
                            local isTracked = isClientTracked(player.UserId)
                            if isTracked then
                                newHighlight.FillColor = Color3.fromRGB(255, 50, 50)
                                newHighlight.OutlineColor = Color3.fromRGB(200, 0, 0)
                            else
                                newHighlight.FillColor = Color3.fromRGB(0, 100, 50)
                                newHighlight.OutlineColor = Color3.fromRGB(0, 150, 75)
                            end
                            
                            newHighlight.FillTransparency = 0.5
                            newHighlight.OutlineTransparency = 0
                            newHighlight.Adornee = currentCharacter
                            newHighlight.Parent = currentCharacter
                            
                            -- Store highlight
                            if not espObjects[player.UserId] then
                                espObjects[player.UserId] = {}
                            end
                            table.insert(espObjects[player.UserId], newHighlight)
                        end)
                    else
                        -- Highlight exists, just ensure it's properly configured
                        pcall(function()
                            if existingHighlight.Adornee ~= currentCharacter then
                                existingHighlight.Adornee = currentCharacter
                            end
                            if existingHighlight.Parent ~= currentCharacter then
                                existingHighlight.Parent = currentCharacter
                            end
                        end)
                    end
                    
                    -- Update colors (this runs regardless)
                    updatePlayerESPColor(player)
                end
            end
        end)
    end

    if player.Character then
        setupESP()
    end

    player.CharacterAdded:Connect(setupESP)
end

local function removeESP(player)
    if espObjects[player.UserId] then
        for _, obj in pairs(espObjects[player.UserId]) do
            if obj and obj.Parent then
                obj:Destroy()
            end
        end
        espObjects[player.UserId] = nil
    end
end

local function refreshAllESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            removeESP(player)
            if ESP_ENABLED then
                createESP(player)
            end
        end
    end
end

local function initializeESP()
    -- Start updating tracked client IDs immediately
    updateTrackedClientIds()
    
    -- Wait a moment for initial client IDs to load
    task.wait(0.5)

    -- Create ESP for existing players
    for _, player in pairs(Players:GetPlayers()) do
        createESP(player)
    end

    -- Create ESP for new players instantly
    Players.PlayerAdded:Connect(function(player)
        task.wait(0.1) -- Small delay for character to load
        createESP(player)
    end)

    -- Remove ESP when players leave
    Players.PlayerRemoving:Connect(function(player)
        removeESP(player)
    end)

    print("üëÅÔ∏è ESP System Initialized (Real-Time Mode)")
    print(" üî¥ Red = Bot Users (with 'Aether Elite user' label)")
    print(" üü¢ Dark Green = Normal Players")
end

-- Settings storage
local Settings = {
    Enabled = false,
    MinValue = 100000000,
    Retries = 3,
    RetryDelay = 2,
    CheckInterval = 2,
    enabled = false,
    PriorityPets = {},
    BlacklistedPets = {}
}

-- Get settings from elite.lua (via _G or file)
local function getEliteSettings()
    -- Try to get from _G first (if elite.lua exposes it)
    if _G.EliteSettings then
        return _G.EliteSettings
    end
    
    -- Try to read from settings file
    local success, fileSettings = pcall(function()
        if readfile and isfile and isfile(SETTINGS_FILE) then
            return HttpService:JSONDecode(readfile(SETTINGS_FILE))
        end
    end)
    
    if success and fileSettings then
        -- Merge with local settings
        if fileSettings.MinValue then Settings.MinValue = tonumber(fileSettings.MinValue) or 100000000 end
        if fileSettings.Retries then Settings.Retries = tonumber(fileSettings.Retries) or 3 end
        if fileSettings.RetryDelay then Settings.RetryDelay = tonumber(fileSettings.RetryDelay) or 2 end
        if fileSettings.PriorityPets then Settings.PriorityPets = fileSettings.PriorityPets or {} end
        if fileSettings.BlacklistedPets then Settings.BlacklistedPets = fileSettings.BlacklistedPets or {} end
        return fileSettings
    end
    
    -- Return default empty settings
    return {
        PriorityPets = {},
        BlacklistedPets = {},
        PET_LIST = {}
    }
end

-- Save settings to file (matching elite.lua)
local function saveSettings()
    pcall(function()
        if writefile then
            local fileData = {
                MinValue = Settings.MinValue,
                Retries = Settings.Retries,
                RetryDelay = Settings.RetryDelay,
                PriorityPets = Settings.PriorityPets,
                BlacklistedPets = Settings.BlacklistedPets
            }
            
            writefile(SETTINGS_FILE, HttpService:JSONEncode(fileData))
            -- Removed print to prevent spam - settings save silently
        end
    end)
end

-- Helper function to check if pet meets minimum value requirements
local function meetsMinimumValue(petName, petValue, isPriority)
    -- Priority pets bypass minimum value
    if isPriority then
        return true
    end
    
    -- Check if pet is in priority list from settings
    if Settings.PriorityPets and Settings.PriorityPets[petName] == true then
        return true
    end
    
    -- Check minimum value
    local minValue = Settings.MinValue or 100000000
    return petValue >= minValue
end

-- Load settings on startup (immediately, before UI loads)
getEliteSettings()
print("[Aether Elite] ‚öôÔ∏è Settings loaded - MinValue:", Settings.MinValue / 1000000, "M/s")

-- Reload settings periodically to catch changes
task.spawn(function()
    while true do
        task.wait(5) -- Reload settings every 5 seconds
        getEliteSettings()
        
        -- Re-initialize pets after reloading settings (matching elite.lua)
        local success, petList = pcall(getPetList)
        if success and petList and #petList > 0 then
            for _, petName in ipairs(petList) do
                if Settings.BlacklistedPets[petName] == nil then
                    Settings.BlacklistedPets[petName] = false
                end
                if Settings.PriorityPets[petName] == nil then
                    Settings.PriorityPets[petName] = false
                end
            end
        end
    end
end)

-- Get pet list from elite.lua or ReplicatedStorage
local function getPetList()
    -- Try to get from _G first
    if _G.PET_LIST and type(_G.PET_LIST) == "table" then
        return _G.PET_LIST
    end
    
    -- Try to get from settings
    local settings = getEliteSettings()
    if settings.PET_LIST and #settings.PET_LIST > 0 then
        return settings.PET_LIST
    end
    
    -- Try to get from ReplicatedStorage (same as elite.lua)
    local names = {}
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local maxAttempts = 10
    for attempt = 1, maxAttempts do
        local models = ReplicatedStorage:FindFirstChild("Models")
        if models then
            local petsFolder = models:FindFirstChild("Pets") or models:FindFirstChild("Animals")
            if petsFolder then
                for _, petModel in pairs(petsFolder:GetChildren()) do
                    if petModel:IsA("Model") or petModel:IsA("Folder") then
                        table.insert(names, petModel.Name)
                    end
                end
                if #names > 0 then
                    break
                end
            end
        end
        if attempt < maxAttempts then
            task.wait(0.5)
        end
    end
    
    table.sort(names)
    return names
end

-- Initialize blacklist and priority pets (matching elite.lua)
-- This ensures all pets exist in the tables, even if not selected
task.spawn(function()
    -- Wait for pet list to be available
    local petList = getPetList()
    if petList and #petList > 0 then
        -- Initialize all pets to false if they don't exist in settings
        for _, petName in ipairs(petList) do
            if Settings.BlacklistedPets[petName] == nil then
                Settings.BlacklistedPets[petName] = false
            end
            if Settings.PriorityPets[petName] == nil then
                Settings.PriorityPets[petName] = false
            end
        end
        print("[Aether Elite] ‚úÖ Initialized " .. #petList .. " pets in PriorityPets and BlacklistedPets")
    end
end)

-- Position saving system (must be defined before use)
local function savePosition(position)
    local positionData = {
        XScale = position.X.Scale,
        XOffset = position.X.Offset,
        YScale = position.Y.Scale,
        YOffset = position.Y.Offset
    }
    
    -- Try to save using writefile (if available in executor)
    pcall(function()
        if type(writefile) == "function" then
            writefile("PrioLogsUI_Position.json", HttpService:JSONEncode(positionData))
        end
    end)
    
    -- Also save to player's data (using a simple key-value approach)
    pcall(function()
        if player:FindFirstChild("PrioLogsUIPosition") then
            player.PrioLogsUIPosition:Destroy()
        end
        local stringValue = Instance.new("StringValue")
        stringValue.Name = "PrioLogsUIPosition"
        stringValue.Value = HttpService:JSONEncode(positionData)
        stringValue.Parent = player
    end)
end

local function loadPosition()
    local savedPosition = nil
    
    -- Try to load from file first (if available in executor)
    pcall(function()
        if type(readfile) == "function" then
            local fileData = readfile("PrioLogsUI_Position.json")
            if fileData then
                savedPosition = HttpService:JSONDecode(fileData)
            end
        end
    end)
    
    -- If file doesn't exist, try loading from player data
    if not savedPosition then
        pcall(function()
            local positionValue = player:FindFirstChild("PrioLogsUIPosition")
            if positionValue then
                savedPosition = HttpService:JSONDecode(positionValue.Value)
            end
        end)
    end
    
    if savedPosition then
        return UDim2.new(
            savedPosition.XScale,
            savedPosition.XOffset,
            savedPosition.YScale,
            savedPosition.YOffset
        )
    end
    
    return nil -- Return nil if no saved position found
end

-- Popup position saving system
local function savePopupPosition(popupName, position)
    local positionData = {
        XScale = position.X.Scale,
        XOffset = position.X.Offset,
        YScale = position.Y.Scale,
        YOffset = position.Y.Offset
    }
    
    -- Try to save using writefile (if available in executor)
    pcall(function()
        if type(writefile) == "function" then
            writefile("PrioLogsUI_" .. popupName .. "_Position.json", HttpService:JSONEncode(positionData))
        end
    end)
    
    -- Also save to player's data
    pcall(function()
        local positionValueName = "PrioLogsUI_" .. popupName .. "_Position"
        if player:FindFirstChild(positionValueName) then
            player[positionValueName]:Destroy()
        end
        local stringValue = Instance.new("StringValue")
        stringValue.Name = positionValueName
        stringValue.Value = HttpService:JSONEncode(positionData)
        stringValue.Parent = player
    end)
end

local function loadPopupPosition(popupName)
    local savedPosition = nil
    
    -- Try to load from file first (if available in executor)
    pcall(function()
        if type(readfile) == "function" then
            local fileData = readfile("PrioLogsUI_" .. popupName .. "_Position.json")
            if fileData then
                savedPosition = HttpService:JSONDecode(fileData)
            end
        end
    end)
    
    -- If file doesn't exist, try loading from player data
    if not savedPosition then
        pcall(function()
            local positionValueName = "PrioLogsUI_" .. popupName .. "_Position"
            local positionValue = player:FindFirstChild(positionValueName)
            if positionValue then
                savedPosition = HttpService:JSONDecode(positionValue.Value)
            end
        end)
    end
    
    if savedPosition then
        return UDim2.new(
            savedPosition.XScale,
            savedPosition.XOffset,
            savedPosition.YScale,
            savedPosition.YOffset
        )
    end
    
    return nil -- Return nil if no saved position found
end

-- Load Slixx's UI Library
local Slixx = loadstring(game:HttpGet("https://raw.githubusercontent.com/GhostDuckyy/UI-Libraries/main/Slixx's/source.lua"))()

-- Set window title
Slixx:SetTitle("Aether Elite")

-- Create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "Aether Elite"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = gui

-- WebSocket Connection Status Indicator (Top Left Corner - Responsive)
local wsStatusGUI = nil
local UserInputService = game:GetService("UserInputService")
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

local wsStatusFrame = Instance.new("Frame")
wsStatusFrame.Name = "WSStatusFrame"
wsStatusFrame.Size = UDim2.new(0, isMobile and 130 or 140, 0, isMobile and 32 or 35)
wsStatusFrame.Position = UDim2.new(0, isMobile and 5 or 10, 0, isMobile and 5 or 10)
wsStatusFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
wsStatusFrame.BackgroundTransparency = 0.2
wsStatusFrame.BorderSizePixel = 0
wsStatusFrame.Parent = screenGui

local wsStatusCorner = Instance.new("UICorner")
wsStatusCorner.CornerRadius = UDim.new(0, 8)
wsStatusCorner.Parent = wsStatusFrame

local wsStatusStroke = Instance.new("UIStroke")
wsStatusStroke.Color = Color3.fromRGB(100, 100, 100)
wsStatusStroke.Thickness = 1.5
wsStatusStroke.Parent = wsStatusFrame

local wsStatusDot = Instance.new("Frame")
wsStatusDot.Name = "StatusDot"
wsStatusDot.Size = UDim2.new(0, 10, 0, 10)
wsStatusDot.Position = UDim2.new(0, 12, 0.5, -5)
wsStatusDot.BackgroundColor3 = Color3.fromRGB(255, 50, 50)  -- Red = disconnected
wsStatusDot.BorderSizePixel = 0
wsStatusDot.Parent = wsStatusFrame

local wsStatusDotCorner = Instance.new("UICorner")
wsStatusDotCorner.CornerRadius = UDim.new(0, 5)
wsStatusDotCorner.Parent = wsStatusDot

local wsStatusLabel = Instance.new("TextLabel")
wsStatusLabel.Name = "StatusLabel"
wsStatusLabel.Size = UDim2.new(1, -30, 1, 0)
wsStatusLabel.Position = UDim2.new(0, 28, 0, 0)
wsStatusLabel.BackgroundTransparency = 1
wsStatusLabel.Text = "Disconnected"
wsStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
wsStatusLabel.TextSize = 14
wsStatusLabel.Font = Enum.Font.GothamBold
wsStatusLabel.TextXAlignment = Enum.TextXAlignment.Left
wsStatusLabel.Parent = wsStatusFrame

-- Store reference for updates
wsStatusGUI = {
    Frame = wsStatusFrame,
    Dot = wsStatusDot,
    Label = wsStatusLabel
}

-- Update WebSocket Status GUI
local function updateWSStatus(connected)
    if wsStatusGUI then
        task.spawn(function()
            if connected then
                wsStatusGUI.Dot.BackgroundColor3 = Color3.fromRGB(50, 255, 50)  -- Green
                wsStatusGUI.Label.Text = "WS: Connected"
                wsStatusGUI.Label.TextColor3 = Color3.fromRGB(50, 255, 50)
            else
                wsStatusGUI.Dot.BackgroundColor3 = Color3.fromRGB(255, 50, 50)  -- Red
                wsStatusGUI.Label.Text = "WS: Disconnected"
                wsStatusGUI.Label.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        end)
    end
end

-- Toggle Button (Top Right Corner) - Always visible
local toggleButton = Instance.new("TextButton")
toggleButton.Name = "ToggleButton"
toggleButton.Size = UDim2.new(0, 120, 0, 40) -- Smaller button for text
toggleButton.Position = UDim2.new(1, -130, 0, 10) -- Top right corner
toggleButton.AnchorPoint = Vector2.new(1, 0) -- Anchor to right edge
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 40) -- Dark background
toggleButton.BackgroundTransparency = 0.2
toggleButton.BorderSizePixel = 0
toggleButton.Text = "Aether" -- Blue text
toggleButton.TextColor3 = Color3.fromRGB(50, 150, 255) -- Bright Blue
toggleButton.TextSize = 18
toggleButton.Font = Enum.Font.GothamBold
toggleButton.ZIndex = 100 -- High ZIndex to always be on top
toggleButton.Parent = screenGui

-- Corner for toggle button
local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 8)
toggleCorner.Parent = toggleButton

-- Glow effect for toggle button (blue theme)
local toggleGlow = Instance.new("UIStroke")
toggleGlow.Name = "Glow"
toggleGlow.Color = Color3.fromRGB(50, 150, 255) -- Blue glow
toggleGlow.Thickness = 2
toggleGlow.Transparency = 0.5
toggleGlow.Parent = toggleButton

-- Hover effect
toggleButton.MouseEnter:Connect(function()
    toggleButton.BackgroundTransparency = 0.1
    toggleGlow.Transparency = 0.3
end)

toggleButton.MouseLeave:Connect(function()
    toggleButton.BackgroundTransparency = 0.2
    toggleGlow.Transparency = 0.5
end)

-- Create Tabs for PRIO, LOGS, IGNORE LIST, and PRIORITY LIST using Slixx
local prioTab = Slixx:NewTab("PRIO", "Priority Settings")
local logsTab = Slixx:NewTab("LOGS", "Pet Logs")
local ignoreListTab = Slixx:NewTab("IGNORE LIST", "Blacklisted Pets")
local priorityListTab = Slixx:NewTab("PRIORITY LIST", "Priority Pets")

-- Logs will be added directly using logsTab:NewButton() - no ScrollingFrame needed!
-- Slixx automatically handles the ScrollingFrame and layout

-- Store toggle references for search filtering
local ignoreListToggles = {} -- [petName] = toggleInstance
local priorityListToggles = {} -- [petName] = toggleInstance

-- Populate tabs directly using Slixx API (no ScrollingFrame needed)
task.spawn(function()
    task.wait(1) -- Wait for Slixx to initialize tabs
    
    -- Get pet list
    local petList = getPetList()
    if not petList or #petList == 0 then
        warn("[Aether Elite] ‚ö†Ô∏è No pets found, retrying...")
        task.wait(2)
        petList = getPetList()
    end
    
    if petList and #petList > 0 then
        -- Populate Ignore List tab
        local ignorePetCount = #petList
        print("[Aether Elite] üìã Populating Ignore List tab with", ignorePetCount, "pets...")
        
        -- Search input with filtering
        local ignoreSearchCallback = function(value)
            local searchTerm = value:lower()
            print("[Search] Searching ignore list for:", searchTerm)
            
            -- Method 1: Use stored container references
            for petName, _ in pairs(ignoreListToggles) do
                if not petName:find("_container") then -- Skip container entries
                    local container = ignoreListToggles[petName .. "_container"]
                    if container and container.Parent then
                        if searchTerm == "" or petName:lower():find(searchTerm) then
                            container.Visible = true
                        else
                            container.Visible = false
                        end
                    end
                end
            end
            
            -- Method 2: Fallback - search through all elements
            if ignoreListTab and ignoreListTab.sectionBG then
                for _, element in pairs(ignoreListTab.sectionBG:GetDescendants()) do
                    if element:IsA("TextLabel") or element:IsA("TextButton") then
                        local text = element.Text or ""
                        if text ~= "" and text ~= "Select All" and text ~= "Clear All" and text ~= "Search" then
                            -- Check if this matches any pet name
                            for petName, _ in pairs(ignoreListToggles) do
                                if not petName:find("_container") and text == petName then
                                    -- Find container
                                    local container = element
                                    while container.Parent and container.Parent ~= ignoreListTab.sectionBG do
                                        if container.Parent:IsA("Frame") or container.Parent:IsA("TextButton") then
                                            container = container.Parent
                                        else
                                            break
                                        end
                                    end
                                    
                                    -- Show/hide
                                    if searchTerm == "" or petName:lower():find(searchTerm) then
                                        container.Visible = true
                                    else
                                        container.Visible = false
                                    end
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
        ignoreListTab:NewTextBox("Search", "Search pets to ignore...", ignoreSearchCallback)
        
        -- Select All button
        local ignoreSelectAllCallback = function()
            if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
            for _, petName in ipairs(petList) do
                Settings.BlacklistedPets[petName] = true
            end
            saveSettings()-- Don't save here - will save when Save button is clicked
        end
        ignoreListTab:NewButton("Select All", ignoreSelectAllCallback)
        
        -- Clear All button
        local ignoreClearAllCallback = function()
            if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
            for _, petName in ipairs(petList) do
                Settings.BlacklistedPets[petName] = false
            end
            saveSettings()-- Don't save here - will save when Save button is clicked
        end
        ignoreListTab:NewButton("Clear All", ignoreClearAllCallback)
        
        -- Add pet toggles
        if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
        for i, petName in ipairs(petList) do
            local isSelected = Settings.BlacklistedPets[petName] == true
            local callback = function(value)
                if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
                Settings.BlacklistedPets[petName] = value
                saveSettings()-- Don't save here - will save when Save button is clicked
            end
            local toggleRef = ignoreListTab:NewToggle(petName, isSelected, callback)
            -- Store toggle reference for search filtering
            ignoreListToggles[petName] = toggleRef
            
            -- Also try to find and store the actual UI instance
            task.spawn(function()
                task.wait(0.1) -- Wait for Slixx to create the UI
                if ignoreListTab and ignoreListTab.sectionBG then
                    for _, descendant in pairs(ignoreListTab.sectionBG:GetDescendants()) do
                        if (descendant:IsA("TextLabel") or descendant:IsA("TextButton")) and descendant.Text == petName then
                            -- Find the container
                            local container = descendant
                            while container.Parent and container.Parent ~= ignoreListTab.sectionBG do
                                if container.Parent:IsA("Frame") or container.Parent:IsA("TextButton") then
                                    container = container.Parent
                                else
                                    break
                                end
                            end
                            -- Store the container reference
                            ignoreListToggles[petName .. "_container"] = container
                            break
                        end
                    end
                end
            end)
            if (i % 10 == 0) then
                task.wait() -- Yield every 10 pets
            end
        end
        print("[Aether Elite] ‚úÖ Ignore List tab populated")
        
        -- Populate Priority List tab
        local petCount = #petList
        print("[Aether Elite] Populating Priority List tab with", petCount, "pets...")
        local prioritySearchCallback = function(value)
            local searchTerm = value:lower()
            print("[Search] Searching priority list for:", searchTerm)
            
            -- Method 1: Use stored container references
            for petName, _ in pairs(priorityListToggles) do
                if not petName:find("_container") then -- Skip container entries
                    local container = priorityListToggles[petName .. "_container"]
                    if container and container.Parent then
                        if searchTerm == "" or petName:lower():find(searchTerm) then
                            container.Visible = true
                        else
                            container.Visible = false
                        end
                    end
                end
            end
            
            -- Method 2: Fallback - search through all elements
            if priorityListTab and priorityListTab.sectionBG then
                for _, element in pairs(priorityListTab.sectionBG:GetDescendants()) do
                    if element:IsA("TextLabel") or element:IsA("TextButton") then
                        local text = element.Text or ""
                        if text ~= "" and text ~= "Select All" and text ~= "Clear All" and text ~= "Search" then
                            -- Check if this matches any pet name
                            for petName, _ in pairs(priorityListToggles) do
                                if not petName:find("_container") and text == petName then
                                    -- Find container
                                    local container = element
                                    while container.Parent and container.Parent ~= priorityListTab.sectionBG do
                                        if container.Parent:IsA("Frame") or container.Parent:IsA("TextButton") then
                                            container = container.Parent
                                        else
                                            break
                                        end
                                    end
                                    
                                    -- Show/hide
                                    if searchTerm == "" or petName:lower():find(searchTerm) then
                                        container.Visible = true
                                    else
                                        container.Visible = false
                                    end
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
        priorityListTab:NewTextBox("Search", "Search pets for priority...", prioritySearchCallback)
        
        -- Select All button
        local prioritySelectAllCallback = function()
            if not Settings.PriorityPets then Settings.PriorityPets = {} end
            for _, petName in ipairs(petList) do
                Settings.PriorityPets[petName] = true
            end
            saveSettings()
        end
        priorityListTab:NewButton("Select All", prioritySelectAllCallback)
        
        -- Clear All button
        local priorityClearAllCallback = function()
            if not Settings.PriorityPets then Settings.PriorityPets = {} end
            for _, petName in ipairs(petList) do
                Settings.PriorityPets[petName] = false
            end
            saveSettings()
        end
        priorityListTab:NewButton("Clear All", priorityClearAllCallback)
        
        -- Add pet toggles
        if not Settings.PriorityPets then Settings.PriorityPets = {} end
        for i, petName in ipairs(petList) do
            local isSelected = Settings.PriorityPets[petName] == true
            local callback = function(value)
                if not Settings.PriorityPets then Settings.PriorityPets = {} end
                Settings.PriorityPets[petName] = value
                saveSettings()
            end
            local toggleRef = priorityListTab:NewToggle(petName, isSelected, callback)
            -- Store toggle reference for search filtering
            priorityListToggles[petName] = toggleRef
            
            -- Also try to find and store the actual UI instance
            task.spawn(function()
                task.wait(0.1) -- Wait for Slixx to create the UI
                if priorityListTab and priorityListTab.sectionBG then
                    for _, descendant in pairs(priorityListTab.sectionBG:GetDescendants()) do
                        if (descendant:IsA("TextLabel") or descendant:IsA("TextButton")) and descendant.Text == petName then
                            -- Find the container
                            local container = descendant
                            while container.Parent and container.Parent ~= priorityListTab.sectionBG do
                                if container.Parent:IsA("Frame") or container.Parent:IsA("TextButton") then
                                    container = container.Parent
                                else
                                    break
                                end
                            end
                            -- Store the container reference
                            priorityListToggles[petName .. "_container"] = container
                            break
                        end
                    end
                end
            end)
            if (i % 10 == 0) then
                task.wait() -- Yield every 10 pets
            end
        end
        print("[Aether Elite] ‚úÖ Priority List tab populated")
    end
end)

-- Function to populate Ignore List tab
local function populateIgnoreListTab(scrollingFrame)
    if not scrollingFrame then return end
    
    -- Clear existing children first
    for _, child in pairs(scrollingFrame:GetChildren()) do
        if child:IsA("TextButton") or child:IsA("Frame") then
            pcall(function() child:Destroy() end)
        end
    end
    
    -- Get pet list with error handling
    local petList = getPetList()
    if not petList or #petList == 0 then
        warn("[Aether Elite] ‚ö†Ô∏è No pets found, retrying...")
        task.wait(2)
        petList = getPetList()
        if not petList or #petList == 0 then
            ignoreListTab:NewButton("No pets found - Click to retry", function()
                populateIgnoreListTab(scrollingFrame)
            end)
            return
        end
    end
    
    -- Search input
    ignoreListTab:NewTextBox("Search", "Search pets to ignore...", function(value)
        -- Filter pets based on search
        for _, child in pairs(scrollingFrame:GetChildren()) do
            if child:IsA("TextButton") then
                local toggleText = child:FindFirstChild("ToggleText")
                if toggleText and toggleText.Text ~= "Select All" and toggleText.Text ~= "Clear All" then
                    if value == "" or toggleText.Text:lower():find(value:lower()) then
                        child.Visible = true
                    else
                        child.Visible = false
                    end
                end
            end
        end
    end)

    -- Select All button
    ignoreListTab:NewButton("Select All", function()
        if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
        local petList = getPetList()
        if petList then
            for _, petName in ipairs(petList) do
                Settings.BlacklistedPets[petName] = true
            end
            saveSettings()
            populateIgnoreListTab(scrollingFrame) -- Refresh
        end
    end)
    
    -- Clear All button
    ignoreListTab:NewButton("Clear All", function()
        if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
        local petList = getPetList()
        if petList then
            for _, petName in ipairs(petList) do
                Settings.BlacklistedPets[petName] = false
            end
            saveSettings()
            populateIgnoreListTab(scrollingFrame) -- Refresh
        end
    end)
    
    -- Add pet toggles
    if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
    
    print("[Aether Elite] üìã Adding", #petList, "pets to Ignore List tab...")
    for i, petName in ipairs(petList) do
        local isSelected = Settings.BlacklistedPets[petName] == true
        pcall(function()
            ignoreListTab:NewToggle(petName, isSelected, function(value)
                if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
                Settings.BlacklistedPets[petName] = value
                saveSettings()
            end)
        end)
        if i % 10 == 0 then
            task.wait() -- Yield every 10 pets to prevent lag
        end
    end
    print("[Aether Elite] ‚úÖ Ignore List tab populated with", #petList, "pets")
end

-- Function to populate Priority List tab
local function populatePriorityListTab(scrollingFrame)
    if not scrollingFrame then return end
    
    -- Clear existing children first
    for _, child in pairs(scrollingFrame:GetChildren()) do
        if child:IsA("TextButton") or child:IsA("Frame") then
            pcall(function() child:Destroy() end)
        end
    end
    
    -- Get pet list with error handling
    local petList = getPetList()
    if not petList or #petList == 0 then
        warn("[Aether Elite] ‚ö†Ô∏è No pets found, retrying...")
        task.wait(2)
        petList = getPetList()
        if not petList or #petList == 0 then
            priorityListTab:NewButton("No pets found - Click to retry", function()
                populatePriorityListTab(scrollingFrame)
            end)
            return
        end
    end
    
    -- Search input
    priorityListTab:NewTextBox("Search", "Search pets for priority...", function(value)
        -- Filter pets based on search
        for _, child in pairs(scrollingFrame:GetChildren()) do
            if child:IsA("TextButton") then
                local toggleText = child:FindFirstChild("ToggleText")
                if toggleText and toggleText.Text ~= "Select All" and toggleText.Text ~= "Clear All" then
                    if value == "" or toggleText.Text:lower():find(value:lower()) then
                        child.Visible = true
                    else
                        child.Visible = false
                    end
                end
            end
        end
    end)
    
    -- Select All button
    priorityListTab:NewButton("Select All", function()
        if not Settings.PriorityPets then Settings.PriorityPets = {} end
        local petList = getPetList()
        if petList then
            for _, petName in ipairs(petList) do
                Settings.PriorityPets[petName] = true
            end
            saveSettings()
            populatePriorityListTab(scrollingFrame) -- Refresh
        end
    end)
    
    -- Clear All button
    priorityListTab:NewButton("Clear All", function()
        if not Settings.PriorityPets then Settings.PriorityPets = {} end
        local petList = getPetList()
        if petList then
            for _, petName in ipairs(petList) do
                Settings.PriorityPets[petName] = false
            end
            saveSettings()
            populatePriorityListTab(scrollingFrame) -- Refresh
        end
    end)
    
    -- Add pet toggles
    if not Settings.PriorityPets then Settings.PriorityPets = {} end
    
    print("[Aether Elite] üìã Adding", #petList, "pets to Priority List tab...")
    for i, petName in ipairs(petList) do
        local isSelected = Settings.PriorityPets[petName] == true
        pcall(function()
            priorityListTab:NewToggle(petName, isSelected, function(value)
                if not Settings.PriorityPets then Settings.PriorityPets = {} end
                Settings.PriorityPets[petName] = value
                saveSettings()
            end)
        end)
        if i % 10 == 0 then
            task.wait() -- Yield every 10 pets to prevent lag
        end
    end
    print("[Aether Elite] ‚úÖ Priority List tab populated with", #petList, "pets")
end

-- LogsContent is now created immediately after logsTab creation above

-- Store reference to main window for toggle functionality
local mainContainer = game:GetService("CoreGui"):FindFirstChild("ScriptedUI")
if not mainContainer then
    mainContainer = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScriptedUI")
end

-- Track which elements we've already set up monitoring for
local whiteTextMonitored = {}

-- Function to make all log button text white
local function makeAllLogTextWhite()
    if logsTab and logsTab.sectionBG then
        for _, descendant in pairs(logsTab.sectionBG:GetDescendants()) do
            if descendant:IsA("TextLabel") then
                -- Make all text labels white (skip empty text)
                if descendant.Text and descendant.Text ~= "" then
                    descendant.TextColor3 = Color3.fromRGB(255, 255, 255)
                    -- Monitor for color changes and restore white (only once per element)
                    if not whiteTextMonitored[descendant] then
                        whiteTextMonitored[descendant] = true
                        descendant:GetPropertyChangedSignal("TextColor3"):Connect(function()
                            if descendant.TextColor3 ~= Color3.fromRGB(255, 255, 255) then
                                descendant.TextColor3 = Color3.fromRGB(255, 255, 255)
                            end
                        end)
                    end
                end
            elseif descendant:IsA("TextButton") and descendant.Text and descendant.Text ~= "" then
                -- Make button text white
                descendant.TextColor3 = Color3.fromRGB(255, 255, 255)
                -- Monitor for color changes and restore white (only once per element)
                if not whiteTextMonitored[descendant] then
                    whiteTextMonitored[descendant] = true
                    descendant:GetPropertyChangedSignal("TextColor3"):Connect(function()
                        if descendant.TextColor3 ~= Color3.fromRGB(255, 255, 255) then
                            descendant.TextColor3 = Color3.fromRGB(255, 255, 255)
                        end
                    end)
                end
            end
        end
    end
end

-- Continuously monitor and make log text white
task.spawn(function()
    while true do
        task.wait(0.3) -- Check every 0.3 seconds
        makeAllLogTextWhite()
    end
end)

-- Function to restore logs when GUI reopens
local function restoreLogs()
    --if not logsTab then return end
    
    -- Store a copy of logDataStore before clearing
    local logsToRestore = {}
    if logDataStore and type(logDataStore) == "table" then
        for serverId, logData in pairs(logDataStore) do
            logsToRestore[serverId] = logData
        end
    end
    
    -- Clear existing log buttons and data store (they might be stale)
    logButtons = {}
    activeLogs = {}
    logDataStore = {} -- Clear this so addLog can recreate buttons
    
    -- Restore all stored logs
    for serverId, logData in pairs(logsToRestore) do
        -- Re-add the log using addLog function
        pcall(function()
            if logData and logData.petName and logData.serverId then
                addLog(
                    logData.petName,
                    logData.petValue,
                    logData.serverId,
                    logData.thumbnailUrl,
                    logData.gui,
                    logData.petValueFormatted,
                    logData.isPriority
                )
            end
        end)
    end
    
    -- Make all log text white after restoring
    task.wait(0.3)
    makeAllLogTextWhite()
end

-- Toggle button click handler - GUI starts minimized
local guiVisible = false -- Start minimized
toggleButton.MouseButton1Click:Connect(function()
    guiVisible = not guiVisible
    
    -- Find ScriptedUI (Slixx's main container)
    local scriptedUI = game:GetService("CoreGui"):FindFirstChild("ScriptedUI")
    if not scriptedUI then
        scriptedUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScriptedUI")
    end
    
    if scriptedUI then
        scriptedUI.Enabled = guiVisible
    end
    
    -- Update mainContainer reference
    if mainContainer then
        mainContainer.Enabled = guiVisible
    end
    
    -- Restore logs when GUI is opened
    if guiVisible then
        task.wait(0.2) -- Wait for Slixx to fully initialize
        restoreLogs()
    end
    
    -- Visual feedback on toggle button
    if guiVisible then
        toggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Brighter blue when open
        toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text when open
        toggleGlow.Color = Color3.fromRGB(100, 200, 255)
        toggleGlow.Transparency = 0.2
    else
        toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 40) -- Dark when closed
        toggleButton.TextColor3 = Color3.fromRGB(50, 150, 255) -- Blue text when closed
        toggleGlow.Color = Color3.fromRGB(50, 150, 255)
        toggleGlow.Transparency = 0.5
    end
end)

-- Hide GUI on startup (minimize)
task.spawn(function()
    task.wait(0.5) -- Wait for Slixx to create the GUI
    local scriptedUI = game:GetService("CoreGui"):FindFirstChild("ScriptedUI")
    if not scriptedUI then
        scriptedUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScriptedUI")
    end
    
    if scriptedUI then
        scriptedUI.Enabled = false -- Start minimized
        mainContainer = scriptedUI
    end
end)

-- Track dot state (false = off/red, true = on/green)
local dotState = false
local startAjoButton = nil
local statusDot = nil

-- Define saveSettingsFromUI before it's used
local function saveSettingsFromUI()
    -- Save min value (convert from M/s to raw value)
    if minMisInput then
        local box = minMisInput:FindFirstChild("TextBox")
        if box then
            local minValueM = tonumber(box.Text)
            if minValueM and minValueM > 0 then
                Settings.MinValue = minValueM * 1000000
            end
        end
    end
    
    -- Save retries
    if retryCountInput then
        local box = retryCountInput:FindFirstChild("TextBox")
        if box then
            local retries = tonumber(box.Text)
            if retries and retries > 0 then
                Settings.Retries = retries
            end
        end
    end
    
    -- Save retry delay
    if retryTimeInput then
        local box = retryTimeInput:FindFirstChild("TextBox")
        if box then
            local retryDelay = tonumber(box.Text)
            if retryDelay and retryDelay >= 0 then
                Settings.RetryDelay = retryDelay
            end
        end
    end
    
    -- PriorityPets and BlacklistedPets are already updated in Settings when user clicks pet buttons
    -- Just save everything to file
    saveSettings()
end

-- START AJO Button using Slixx
startAjoButton = prioTab:NewButton("‚ñ∂ START", function()
    -- Check if button is in STOP state (currently joining)
    if dotState and currentlyJoining then
        -- Stop the join process
        print("STOP clicked - stopping join")
        stopJoining = true
        currentlyJoining = false
        dotState = false
        if statusDot then
            statusDot.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red
        end
        if startAjoButton then
            local toggleText = startAjoButton:FindFirstChild("ToggleText")
            if toggleText then
                toggleText.Text = "‚ñ∂ START"
            end
        end
        Settings.Enabled = false
        print("Status: OFF (Red) - START")
        return
    end
    
    print("START AJ clicked")
    
    -- Save settings before starting
    pcall(saveSettingsFromUI)
    
    -- Toggle dot state
    dotState = not dotState
    
    -- Update dot color and button text based on state
    if dotState then
        -- On state - Green dot, show STOP (enable auto-join)
        if statusDot then
            statusDot.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Green
        end
        if startAjoButton then
            local toggleText = startAjoButton:FindFirstChild("ToggleText")
            if toggleText then
                toggleText.Text = "‚è∏ STOP"
            end
        end
        Settings.Enabled = true
        stopJoining = false -- Reset stop flag when enabling
        print("Status: ON (Green) - STOP")
        print(string.format("Settings: MinValue=%.0f M/s, Retries=%d, RetryDelay=%.1fs", 
            Settings.MinValue / 1000000, Settings.Retries, Settings.RetryDelay))
    else
        -- Off state - Red dot, show START (disable auto-join)
        if statusDot then
            statusDot.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red
        end
        if startAjoButton then
            local toggleText = startAjoButton:FindFirstChild("ToggleText")
            if toggleText then
                toggleText.Text = "‚ñ∂ START"
            end
        end
        Settings.Enabled = false
        stopJoining = true -- Set stop flag when disabling
        currentlyJoining = false
        print("Status: OFF (Red) - START")
    end
end)

-- Add status dot indicator to START button
task.spawn(function()
    task.wait(0.1) -- Wait for button to be created
    if startAjoButton then
        statusDot = Instance.new("Frame")
statusDot.Name = "StatusDot"
statusDot.Size = UDim2.new(0, 15, 0, 15)
statusDot.Position = UDim2.new(1, -23, 0.5, 0)
statusDot.AnchorPoint = Vector2.new(0, 0.5)
statusDot.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red (off state)
statusDot.BackgroundTransparency = 0.15
statusDot.BorderSizePixel = 0
        statusDot.ZIndex = 10
statusDot.Parent = startAjoButton

local statusDotCorner = Instance.new("UICorner")
statusDotCorner.CornerRadius = UDim.new(1, 0)
statusDotCorner.Parent = statusDot
    end
end)

-- Minimum value Text Input using Slixx (auto-save on change)
local minMisInput = prioTab:NewTextBox("Minimum value(M/s)", "Enter minimum value in M/s", function(value)
    local minValueM = tonumber(value)
    if minValueM and minValueM > 0 then
        Settings.MinValue = minValueM * 1000000
        saveSettings() -- Auto-save when changed
    end
end)

-- Set initial value
task.spawn(function()
    task.wait(0.1)
    if minMisInput then
        local box = minMisInput:FindFirstChild("TextBox")
        if box then
            box.Text = tostring(Settings.MinValue / 1000000)
        end
    end
end)

-- Join Retries Text Input using Slixx (auto-save on change)
local retryCountInput = prioTab:NewTextBox("Join retries", "Enter number of retries", function(value)
    local retries = tonumber(value)
    if retries and retries > 0 then
        Settings.Retries = retries
        saveSettings() -- Auto-save when changed
    end
end)

-- Set initial value (with retry logic for Slixx)
task.spawn(function()
    task.wait(1) -- Wait longer for Slixx to create TextBox
    local maxRetries = 5
    for i = 1, maxRetries do
        if retryCountInput then
            local box = nil
            if type(retryCountInput) == "table" and retryCountInput.Text then
                retryCountInput.Text = tostring(Settings.Retries)
                print("[Aether Elite] ‚úÖ Retries loaded:", Settings.Retries)
                break
            elseif retryCountInput:IsA("Instance") then
                box = retryCountInput:FindFirstChild("TextBox") or retryCountInput:FindFirstChild("Text") or retryCountInput:FindFirstChild("Input")
                if box then
                    box.Text = tostring(Settings.Retries)
                    print("[Aether Elite] ‚úÖ Retries loaded:", Settings.Retries)
                    break
                end
            end
        end
        if i < maxRetries then
            task.wait(0.5)
        end
    end
end)

-- Retry Delay Text Input using Slixx (auto-save on change)
local retryTimeInput = prioTab:NewTextBox("Retry delay(seconds)", "Enter retry delay in seconds", function(value)
    local retryDelay = tonumber(value)
    if retryDelay and retryDelay >= 0 then
        Settings.RetryDelay = retryDelay
        saveSettings() -- Auto-save when changed
    end
end)

-- Set initial value (with retry logic for Slixx)
task.spawn(function()
    task.wait(1) -- Wait longer for Slixx to create TextBox
    local maxRetries = 5
    for i = 1, maxRetries do
        if retryTimeInput then
            local box = nil
            if type(retryTimeInput) == "table" and retryTimeInput.Text then
                retryTimeInput.Text = tostring(Settings.RetryDelay)
                print("[Aether Elite] ‚úÖ RetryDelay loaded:", Settings.RetryDelay, "s")
                break
            elseif retryTimeInput:IsA("Instance") then
                box = retryTimeInput:FindFirstChild("TextBox") or retryTimeInput:FindFirstChild("Text") or retryTimeInput:FindFirstChild("Input")
                if box then
                    box.Text = tostring(Settings.RetryDelay)
                    print("[Aether Elite] ‚úÖ RetryDelay loaded:", Settings.RetryDelay, "s")
                    break
                end
            end

        end
        if i < maxRetries then
            task.wait(0.5)
        end
    end
end)

-- Note: Ignore List and Priority List are now separate tabs, no buttons needed

-- SAVE SETTINGS Button using Slixx
local saveSettingsButton = prioTab:NewButton("üíæ Save Settings", function()
    pcall(saveSettingsFromUI)
    
    -- Visual feedback
    if saveSettingsButton then
        local toggleText = saveSettingsButton:FindFirstChild("ToggleText")
        if toggleText then
            local originalText = toggleText.Text
            toggleText.Text = "‚úÖ Saved!"
            saveSettingsButton.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
            
            task.wait(1)
            
            toggleText.Text = originalText
            saveSettingsButton.BackgroundColor3 = Color3.fromRGB(50, 150, 100)
        end
    end
end)

-- LOGS Content Area - Using Slixx's NewButton API directly (like PRIO tab)
-- No need for manual ScrollingFrame - Slixx handles it automatically!
local logButtons = {} -- Track log buttons to prevent duplicates

-- Close Button - Slixx handles window closing via LeftControl key
local closeButton = nil -- Slixx doesn't have a close button, uses LeftControl to toggle

-- Track active logs (like elite.lua)
local activeLogs = {}
local logDataStore = {} -- Store log data separately to restore when GUI reopens
local processedServers = {}
local stopJoining = false
local currentlyJoining = false

-- Function to ensure logsContent is initialized and available
local function ensureLogsContentReady()
    -- Check if logsContent exists and is valid
    local isValid = pcall(function()
        if logsContent then
            local _ = logsContent.Name -- Test if instance is valid
            return true
        end
        return false
    end)
    
    -- If logsContent doesn't exist or is invalid, recreate it
    if not isValid or not logsContent then
        -- Clean up old instance if it exists but is invalid
        if logsContent then
            pcall(function() logsContent:Destroy() end)
        end
        
        logsContent = Instance.new("ScrollingFrame")
        logsContent.Name = "LogsContent"
        logsContent.Size = UDim2.new(1, -20, 1, -38)
        logsContent.Position = UDim2.new(0, 10, 0, 38)
        logsContent.BackgroundTransparency = 1
        logsContent.BorderSizePixel = 0
        logsContent.ScrollBarThickness = 6
        logsContent.ScrollBarImageColor3 = Color3.fromRGB(50, 150, 255)
        logsContent.CanvasSize = UDim2.new(0, 0, 0, 0)
    end
    
    -- Ensure logsContent is set to Slixx's ScrollingFrame
    if not logsContent or not logsContent.Parent then
        -- Try to get ScrollingFrame from logsTab
        if logsTab and logsTab.sectionBG then
            local foundScrollingFrame = logsTab.sectionBG:FindFirstChild("ScrollingFrame")
            if foundScrollingFrame then
                logsContent = foundScrollingFrame
                logsContent.Name = "LogsContent"
                
                -- Ensure listLayout exists
                if not listLayout or not listLayout.Parent then
                    local existingLayout = logsContent:FindFirstChild("UIListLayout")
                    if existingLayout then
                        existingLayout:Destroy()
                    end
                    
                    listLayout = Instance.new("UIListLayout")
                    listLayout.Name = "ListLayout"
                    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
                    listLayout.Padding = UDim.new(0, 8)
                    listLayout.Parent = logsContent
                end
                
                    return true
                end
            end
        
        -- Try to find from CoreGui ScriptedUI
        local scriptedUI = game:GetService("CoreGui"):FindFirstChild("ScriptedUI")
        if not scriptedUI then
            scriptedUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScriptedUI")
        end
        
        if scriptedUI then
            local backgroundFrame = scriptedUI:FindFirstChild("BackgroundFrame")
            if backgroundFrame then
                -- Find LOGS tab section
                for _, child in pairs(backgroundFrame:GetChildren()) do
                    if child:IsA("Frame") and child.Name ~= "TabBG" then
                        local sectionTitle = child:FindFirstChild("SectionTitle")
                        if sectionTitle and sectionTitle.Text == "LOGS" then
                            local foundScrollingFrame = child:FindFirstChild("ScrollingFrame")
                            if foundScrollingFrame then
                                logsContent = foundScrollingFrame
                                logsContent.Name = "LogsContent"
                                
                                -- Ensure listLayout exists
                                if not listLayout or not listLayout.Parent then
                                    local existingLayout = logsContent:FindFirstChild("UIListLayout")
                                    if existingLayout then
                                        existingLayout:Destroy()
                                    end
                                    
                                    listLayout = Instance.new("UIListLayout")
                                    listLayout.Name = "ListLayout"
                                    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
                                    listLayout.Padding = UDim.new(0, 8)
                                    listLayout.Parent = logsContent
                                end
                                
                    return true
                            end
                        end
                    end
                end
            end
        end
        
        -- If we get here, UI might not be initialized yet - don't warn, just return false
        -- The main loop will retry later
        return false
    end
    
    -- Ensure listLayout exists
    if not listLayout or not listLayout.Parent then
        local layoutValid = pcall(function()
            if listLayout then
                local _ = listLayout.Name
                return true
            end
            return false
        end)
        
        if not layoutValid and listLayout then
            pcall(function() listLayout:Destroy() end)
        end
        
        listLayout = Instance.new("UIListLayout")
        listLayout.Name = "ListLayout"
        listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        listLayout.Padding = UDim.new(0, 8)
        
        local success = pcall(function()
            listLayout.Parent = logsContent
        end)
        if not success then
            warn("[Aether Elite] ‚ö†Ô∏è Failed to set listLayout parent")
            return false
        end
    end
    
    return logsContent and logsContent.Parent ~= nil
end

-- Continuous canvas size update (like elite.lua)
task.spawn(function()
    while logsContent and logsContent.Parent do
        if logsContent.Parent and listLayout and listLayout.Parent then
            task.wait(0.1)
            local contentSize = listLayout.AbsoluteContentSize
            logsContent.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
        else
            task.wait(1)
        end
    end
end)

-- Animation Service
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")

-- Track GUI visibility state
local guiVisible = true

-- Verification: Ensure Slixx UI is loaded
task.spawn(function()
    task.wait(0.2) -- Wait for Slixx to create UI
    
    -- Find and change the "Aether Elite" title color to blue (and keep it blue)
    task.wait(0.5) -- Wait a bit more for Slixx to fully create the UI
    local scriptedUI = game:GetService("CoreGui"):FindFirstChild("ScriptedUI")
    if not scriptedUI then
        scriptedUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScriptedUI")
    end
    
    local function setTitleBlue()
        if scriptedUI then
            -- Search for the title TextLabel
            local function findTitleLabel(parent)
                for _, child in pairs(parent:GetDescendants()) do
                    if child:IsA("TextLabel") and child.Text == "Aether Elite" then
                        return child
                    end
                end
                return nil
            end
            
            local titleLabel = findTitleLabel(scriptedUI)
            if titleLabel then
                titleLabel.TextColor3 = Color3.fromRGB(50, 150, 255) -- Bright Blue
                -- Monitor for color changes and restore blue if it changes
                titleLabel:GetPropertyChangedSignal("TextColor3"):Connect(function()
                    if titleLabel.TextColor3 ~= Color3.fromRGB(50, 150, 255) then
                        titleLabel.TextColor3 = Color3.fromRGB(50, 150, 255)
                    end
                end)
                print("[Aether Elite] ‚úÖ Title color set to blue and locked")
            else
                -- Try searching in BackgroundFrame
                local backgroundFrame = scriptedUI:FindFirstChild("BackgroundFrame")
                if backgroundFrame then
                    titleLabel = findTitleLabel(backgroundFrame)
                    if titleLabel then
                        titleLabel.TextColor3 = Color3.fromRGB(50, 150, 255) -- Bright Blue
                        -- Monitor for color changes and restore blue if it changes
                        titleLabel:GetPropertyChangedSignal("TextColor3"):Connect(function()
                            if titleLabel.TextColor3 ~= Color3.fromRGB(50, 150, 255) then
                                titleLabel.TextColor3 = Color3.fromRGB(50, 150, 255)
                            end
                        end)
                        print("[Aether Elite] ‚úÖ Title color set to blue and locked")
                    end
                end
            end
        end
    end
    
    -- Set title color initially
    setTitleBlue()
    
    -- Keep checking and setting title color periodically (in case Slixx recreates it)
    task.spawn(function()
        while true do
            task.wait(2)
            setTitleBlue()
        end
    end)
    
    if prioTab and prioTab.sectionBG then
        print("[Aether Elite] ‚úÖ PRIO tab created")
    end
    if logsTab and logsTab.sectionBG then
        print("[Aether Elite] ‚úÖ LOGS tab created")
    end
    if logsContent then
        print("[Aether Elite] ‚úÖ LOGS content ScrollingFrame ready")
    end
    if logsContent then
        logsContent.Visible = true
        logsContent.ZIndex = 11
        print("[Aether Elite] ‚úÖ LOGS content area created and visible")
    end
    -- mainContainer is a ScreenGui, doesn't have Size property
    if mainContainer then
        print("[Aether Elite] ‚úÖ Main container (ScreenGui) initialized")
    end
    print("[Aether Elite] ‚úÖ PRIO container position:", prioContainer and prioContainer.Position.X.Scale or "nil")
    print("[Aether Elite] ‚úÖ LOGS container position:", logsContainer and logsContainer.Position.X.Scale or "nil")
    
    -- Note: Test log entry will be added after addLog function is defined (see end of file)
end)

-- Button hover animations
local function addHoverAnimation(button)
    if not button or not button.Parent then return end
    pcall(function()
        if not button:IsA("GuiButton") then return end -- Only work on buttons
    local originalTransparency = button.BackgroundTransparency
    local hoverTween = nil
    
    button.MouseEnter:Connect(function()
        if hoverTween then hoverTween:Cancel() end
        hoverTween = TweenService:Create(button, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            BackgroundTransparency = math.max(0, originalTransparency - 0.15)
        })
        hoverTween:Play()
    end)
    
    button.MouseLeave:Connect(function()
        if hoverTween then hoverTween:Cancel() end
        hoverTween = TweenService:Create(button, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            BackgroundTransparency = originalTransparency
        })
        hoverTween:Play()
        end)
    end)
end

-- Apply hover animations to buttons that exist
if toggleButton then addHoverAnimation(toggleButton) end
if startAjoButton then addHoverAnimation(startAjoButton) end
-- ignorePetsButton and onlyJoinPetsButton don't exist anymore (using tabs instead)
-- closeButton doesn't exist (Slixx handles window closing)

-- Function to toggle GUI visibility
local function toggleGUI()
    guiVisible = not guiVisible
    
    if guiVisible then
        -- Show GUI
        if mainContainer then
            mainContainer.Enabled = true
        end
        -- Ensure tabs are visible (Slixx handles this)
        if logsContent then logsContent.Visible = true end
    else
        -- Hide GUI
        mainContainer.Visible = false
    end
end

-- P Key Toggle Functionality
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end -- Don't trigger if typing in chat or other UI
    
    if input.KeyCode == Enum.KeyCode.P then
        toggleGUI()
    end
end)

-- Close Button Functionality - Slixx handles window closing with LeftControl key
-- No closeButton exists anymore, so this code is removed

-- Drag Functionality for Main Container
local UserInputService = game:GetService("UserInputService")
local mainDragging = false
local mainDragStart = nil
local mainStartPos = nil

local function updateMainInput(input)
    local delta = input.Position - mainDragStart
    local newPos = UDim2.new(
        mainStartPos.X.Scale,
        mainStartPos.X.Offset + delta.X,
        mainStartPos.Y.Scale,
        mainStartPos.Y.Offset + delta.Y
    )
    mainContainer.Position = newPos
end

local function onMainDragStart(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        mainDragging = true
        mainDragStart = input.Position
        mainStartPos = mainContainer.Position
        
        -- Update anchor point if needed (convert from center to top-left)
        if mainContainer.AnchorPoint ~= Vector2.new(0, 0) then
            local currentPos = mainContainer.Position
            local screenSize = workspace.CurrentCamera.ViewportSize
            local newX = currentPos.X.Offset + (currentPos.X.Scale * screenSize.X) - (mainContainer.Size.X.Offset / 2)
            local newY = currentPos.Y.Offset + (currentPos.Y.Scale * screenSize.Y) - (mainContainer.Size.Y.Offset / 2)
            mainContainer.AnchorPoint = Vector2.new(0, 0)
            mainContainer.Position = UDim2.new(0, newX, 0, newY)
            mainStartPos = mainContainer.Position
        end
        
        local connection
        connection = input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                mainDragging = false
                -- Save position when drag ends
                savePosition(mainContainer.Position)
                connection:Disconnect()
            end
        end)
    end
end

local function onMainDrag(input)
    if mainDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        updateMainInput(input)
    end
end

-- Make main container draggable (Slixx handles window dragging)
-- Drag functionality is handled by Slixx window

-- Load settings into input fields
local function loadSettingsToUI()
    -- Load min value (convert from raw value to M/s)
    if minMisInput then
        -- Slixx TextBox is a table with a Text property or an Instance
        pcall(function()
            if type(minMisInput) == "table" then
                -- Try to set Text property directly
                if minMisInput.Text ~= nil then
                    minMisInput.Text = tostring(Settings.MinValue / 1000000)
                elseif minMisInput.SetText then
                    minMisInput:SetText(tostring(Settings.MinValue / 1000000))
                end
            elseif minMisInput:IsA("Instance") then
                -- Find TextBox child
                local box = minMisInput:FindFirstChild("TextBox") or minMisInput:FindFirstChild("Text") or minMisInput:FindFirstChild("Input")
                if box then
                    box.Text = tostring(Settings.MinValue / 1000000)
                end
    end
end)
    end
    
    -- Load retries
    if retryCountInput then
        pcall(function()
            if type(retryCountInput) == "table" then
                if retryCountInput.Text ~= nil then
                    retryCountInput.Text = tostring(Settings.Retries)
                elseif retryCountInput.SetText then
                    retryCountInput:SetText(tostring(Settings.Retries))
                end
            elseif retryCountInput:IsA("Instance") then
                local box = retryCountInput:FindFirstChild("TextBox") or retryCountInput:FindFirstChild("Text") or retryCountInput:FindFirstChild("Input")
                if box then
                    box.Text = tostring(Settings.Retries)
                end
    end
end)
    end
    
    -- Load retry delay
    if retryTimeInput then
        pcall(function()
            if type(retryTimeInput) == "table" then
                if retryTimeInput.Text ~= nil then
    retryTimeInput.Text = tostring(Settings.RetryDelay)
                elseif retryTimeInput.SetText then
                    retryTimeInput:SetText(tostring(Settings.RetryDelay))
                end
            elseif retryTimeInput:IsA("Instance") then
                local box = retryTimeInput:FindFirstChild("TextBox") or retryTimeInput:FindFirstChild("Text") or retryTimeInput:FindFirstChild("Input")
                if box then
                    box.Text = tostring(Settings.RetryDelay)
                end
            end
        end)
    end
end

-- Save settings from input fields (matching elite.lua)
local function saveSettingsFromUI()
    -- Save min value (convert from M/s to raw value)
    if minMisInput then
        local box = minMisInput:FindFirstChild("TextBox")
        if box then
            local minValueM = tonumber(box.Text)
    if minValueM and minValueM > 0 then
        Settings.MinValue = minValueM * 1000000
            end
        end
    end
    
    -- Save retries
    if retryCountInput then
        local box = retryCountInput:FindFirstChild("TextBox")
        if box then
            local retries = tonumber(box.Text)
    if retries and retries > 0 then
        Settings.Retries = retries
            end
        end
    end
    
    -- Save retry delay
    if retryTimeInput then
        local box = retryTimeInput:FindFirstChild("TextBox")
        if box then
            local retryDelay = tonumber(box.Text)
    if retryDelay and retryDelay >= 0 then
        Settings.RetryDelay = retryDelay
            end
        end
    end
    
    -- PriorityPets and BlacklistedPets are already updated in Settings when user clicks pet buttons
    -- Just save everything to file
    saveSettings()
    
    -- Count priority and blacklisted pets
    local priorityCount = 0
    local blacklistCount = 0
    if Settings.PriorityPets then
        for _, v in pairs(Settings.PriorityPets) do
            if v == true then priorityCount = priorityCount + 1 end
        end
    end
    if Settings.BlacklistedPets then
        for _, v in pairs(Settings.BlacklistedPets) do
            if v == true then blacklistCount = blacklistCount + 1 end
        end
    end
    
    print(string.format("[Settings Saved] MinValue: %.0f M/s | Retries: %d | RetryDelay: %.1fs | PriorityPets: %d | BlacklistedPets: %d",
        Settings.MinValue / 1000000, Settings.Retries, Settings.RetryDelay, priorityCount, blacklistCount))
end

-- Load settings into UI immediately and on rejoin
-- This ensures settings persist when rejoining the server
task.spawn(function()
    -- Load settings from file first
    loadSettings()
    
    -- Wait for Slixx to create all UI elements
    task.wait(3)
    
    -- Try to load settings into UI multiple times to ensure they're set
    local maxRetries = 10
    for i = 1, maxRetries do
        loadSettingsToUI()
        
        -- Verify settings were loaded
        task.wait(0.2)
        
        -- Check if at least one setting was loaded
        local verified = false
        pcall(function()
            if minMisInput then
                if type(minMisInput) == "table" and minMisInput.Text then
                    local val = tonumber(minMisInput.Text)
                    if val and val > 0 then verified = true end
                elseif minMisInput:IsA("Instance") then
                    local box = minMisInput:FindFirstChild("TextBox") or minMisInput:FindFirstChild("Text")
                    if box and box.Text ~= "" then verified = true end
                end
    end
end)

        if verified then
            print("[Aether Elite] ‚úÖ Settings loaded into UI - MinValue:", Settings.MinValue / 1000000, "M/s | Retries:", Settings.Retries, "| RetryDelay:", Settings.RetryDelay, "s")
            break
        end
        
        if i < maxRetries then
            task.wait(0.5)
        end
    end
end)

-- Button handlers are already set up via Slixx callbacks above



-- Track open popups
local openPopups = {}

-- Function to create Ignore List GUI (Dark Blue/Blocked Theme)
local function toggleIgnoreListPopup()
    local popupName = "IgnoreListPopup"
    local existingPopup = screenGui:FindFirstChild(popupName)
    
    if existingPopup then
        existingPopup:Destroy()
        openPopups[popupName] = nil
        return nil, nil
    end
    
    -- Create popup container
    local popupContainer = Instance.new("Frame")
    popupContainer.Name = popupName
    popupContainer.Size = UDim2.new(0, 420, 0, 480)
    
    local savedPopupPos = loadPopupPosition(popupName)
    if savedPopupPos then
        popupContainer.Position = savedPopupPos
        popupContainer.AnchorPoint = Vector2.new(0, 0)
    else
        popupContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
        popupContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    end
    
    popupContainer.BackgroundColor3 = Color3.fromRGB(15, 25, 45) -- Dark Blue
    popupContainer.BackgroundTransparency = 0.05
    popupContainer.BorderSizePixel = 0
    popupContainer.ZIndex = 20
    popupContainer.Parent = screenGui
    
    local popupCorner = Instance.new("UICorner")
    popupCorner.CornerRadius = UDim.new(0, 15)
    popupCorner.Parent = popupContainer
    
    -- Bright blue border
    local popupBorder = Instance.new("UIStroke")
    popupBorder.Color = Color3.fromRGB(80, 180, 255) -- Bright Blue
    popupBorder.Thickness = 4
    popupBorder.Transparency = 0.15
    popupBorder.Parent = popupContainer
    
    -- Header (Bright Blue)
    local popupHeader = Instance.new("Frame")
    popupHeader.Name = "PopupHeader"
    popupHeader.Size = UDim2.new(1, 0, 0, 50)
    popupHeader.Position = UDim2.new(0, 0, 0, 0)
    popupHeader.BackgroundColor3 = Color3.fromRGB(30, 60, 100) -- Bright Blue
    popupHeader.BackgroundTransparency = 0.1
    popupHeader.BorderSizePixel = 0
    popupHeader.ZIndex = 21
    popupHeader.Parent = popupContainer
    
    local popupHeaderCorner = Instance.new("UICorner")
    popupHeaderCorner.CornerRadius = UDim.new(0, 15)
    popupHeaderCorner.Parent = popupHeader
    
    -- Bright blue gradient effect
    local gradientTop = Instance.new("Frame")
    gradientTop.Name = "GradientTop"
    gradientTop.Size = UDim2.new(1, 0, 0, 4)
    gradientTop.Position = UDim2.new(0, 0, 0, 0)
    gradientTop.BackgroundColor3 = Color3.fromRGB(100, 200, 255) -- Bright Blue
    gradientTop.BackgroundTransparency = 0.3
    gradientTop.BorderSizePixel = 0
    gradientTop.ZIndex = 22
    gradientTop.Parent = popupHeader
    
    -- Title label
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, -75, 1, 0)
    titleLabel.Position = UDim2.new(0, 20, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "üö´ IGNORE LIST"
    titleLabel.TextColor3 = Color3.fromRGB(150, 220, 255) -- Bright Blue
    titleLabel.TextSize = 24
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextYAlignment = Enum.TextYAlignment.Center
    titleLabel.ZIndex = 23
    titleLabel.Parent = popupHeader
    
    -- Close button
    local popupCloseButton = Instance.new("TextButton")
    popupCloseButton.Name = "PopupCloseButton"
    popupCloseButton.Size = UDim2.new(0, 38, 0, 38)
    popupCloseButton.Position = UDim2.new(1, -42, 0.5, 0)
    popupCloseButton.AnchorPoint = Vector2.new(0, 0.5)
    popupCloseButton.BackgroundColor3 = Color3.fromRGB(30, 60, 120) -- Bright Blue
    popupCloseButton.BackgroundTransparency = 0.15
    popupCloseButton.BorderSizePixel = 0
    popupCloseButton.Text = "‚úï"
    popupCloseButton.TextColor3 = Color3.fromRGB(180, 240, 255) -- Very Light Blue
    popupCloseButton.TextSize = 22
    popupCloseButton.Font = Enum.Font.GothamBold
    popupCloseButton.ZIndex = 24
    popupCloseButton.Parent = popupHeader
    
    local popupCloseCorner = Instance.new("UICorner")
    popupCloseCorner.CornerRadius = UDim.new(0, 10)
    popupCloseCorner.Parent = popupCloseButton
    
    -- Search input field
    local placeholderInput = Instance.new("TextBox")
    placeholderInput.Name = "PlaceholderInput"
    placeholderInput.Size = UDim2.new(1, -20, 0, 38)
    placeholderInput.Position = UDim2.new(0, 10, 0, 60)
    placeholderInput.BackgroundColor3 = Color3.fromRGB(25, 45, 85) -- Dark Blue
    placeholderInput.BackgroundTransparency = 0.2
    placeholderInput.BorderSizePixel = 0
    placeholderInput.Text = ""
    placeholderInput.PlaceholderText = "üîç Search pets to ignore..."
    placeholderInput.PlaceholderColor3 = Color3.fromRGB(120, 180, 220) -- Blue tinted gray
    placeholderInput.TextColor3 = Color3.fromRGB(200, 240, 255) -- Very Light Blue
    placeholderInput.TextSize = 15
    placeholderInput.Font = Enum.Font.GothamBold
    placeholderInput.TextXAlignment = Enum.TextXAlignment.Left
    placeholderInput.ClearTextOnFocus = false
    placeholderInput.Parent = popupContainer
    
    local placeholderCorner = Instance.new("UICorner")
    placeholderCorner.CornerRadius = UDim.new(0, 10)
    placeholderCorner.Parent = placeholderInput
    
    -- Buttons container
    local buttonsContainer = Instance.new("Frame")
    buttonsContainer.Name = "ButtonsContainer"
    buttonsContainer.Size = UDim2.new(1, -20, 0, 38)
    buttonsContainer.Position = UDim2.new(0, 10, 0, 106)
    buttonsContainer.BackgroundTransparency = 1
    buttonsContainer.Parent = popupContainer
    
    -- Select All button
    local selectAllButton = Instance.new("TextButton")
    selectAllButton.Name = "SelectAllButton"
    selectAllButton.Size = UDim2.new(0.48, 0, 1, 0)
    selectAllButton.Position = UDim2.new(0, 0, 0, 0)
    selectAllButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue (matching log entries)
    selectAllButton.BackgroundTransparency = 0.2
    selectAllButton.BorderSizePixel = 0
    selectAllButton.Text = "Select All"
    selectAllButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White
    selectAllButton.TextSize = 14
    selectAllButton.Font = Enum.Font.GothamBold
    selectAllButton.Parent = buttonsContainer
    
    local selectAllCorner = Instance.new("UICorner")
    selectAllCorner.CornerRadius = UDim.new(0, 8)
    selectAllCorner.Parent = selectAllButton
    
    -- Clear All button
    local clearAllButton = Instance.new("TextButton")
    clearAllButton.Name = "ClearAllButton"
    clearAllButton.Size = UDim2.new(0.48, 0, 1, 0)
    clearAllButton.Position = UDim2.new(0.52, 0, 0, 0)
    clearAllButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue (matching log entries)
    clearAllButton.BackgroundTransparency = 0.2
    clearAllButton.BorderSizePixel = 0
    clearAllButton.Text = "Clear All"
    clearAllButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White
    clearAllButton.TextSize = 14
    clearAllButton.Font = Enum.Font.GothamBold
    clearAllButton.Parent = buttonsContainer
    
    local clearAllCorner = Instance.new("UICorner")
    clearAllCorner.CornerRadius = UDim.new(0, 8)
    clearAllCorner.Parent = clearAllButton
    
    -- Content area
    local popupContent = Instance.new("ScrollingFrame")
    popupContent.Name = "PopupContent"
    popupContent.Size = UDim2.new(1, -12, 1, -160)
    popupContent.Position = UDim2.new(0, 10, 0, 152)
    popupContent.BackgroundTransparency = 1
    popupContent.BorderSizePixel = 0
    popupContent.ScrollBarThickness = 10
    popupContent.ScrollBarImageColor3 = Color3.fromRGB(100, 200, 255) -- Bright Blue scrollbar
    popupContent.CanvasSize = UDim2.new(0, 0, 0, 0)
    popupContent.Parent = popupContainer
    
    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0, 188, 0, 35)
    gridLayout.CellPadding = UDim2.new(0, 8, 0, 8)
    gridLayout.SortOrder = Enum.SortOrder.Name
    gridLayout.Parent = popupContent
    
    local petList = getPetList()
    local settings = getEliteSettings()
    if settings.BlacklistedPets and type(settings.BlacklistedPets) == "table" then 
        Settings.BlacklistedPets = settings.BlacklistedPets 
    end
    if not Settings.BlacklistedPets or type(Settings.BlacklistedPets) ~= "table" then
        Settings.BlacklistedPets = {}
    end
    local petButtons = {}
    
    local function createPetButton(petName)
        local button = Instance.new("TextButton")
        button.Name = petName
        button.BackgroundColor3 = Color3.fromRGB(25, 45, 85) -- Dark Blue
        button.BackgroundTransparency = 0.25
        button.Text = petName
        button.TextColor3 = Color3.fromRGB(170, 220, 255) -- Light Blue
        button.TextSize = 13
        button.Font = Enum.Font.GothamBold
        button.BorderSizePixel = 0
        button.TextXAlignment = Enum.TextXAlignment.Center
        button.TextTruncate = Enum.TextTruncate.AtEnd
        button.Parent = popupContent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = button
        
        local isSelected = Settings.BlacklistedPets and Settings.BlacklistedPets[petName] == true
        
        if isSelected then
            button.BackgroundColor3 = Color3.fromRGB(80, 180, 255) -- Bright Blue when selected
            button.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
        end
        
        button.MouseButton1Click:Connect(function()
            isSelected = not isSelected
            
            if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
            Settings.BlacklistedPets[petName] = isSelected
            
            saveSettings()
            
            if isSelected then
                button.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
            else
                button.BackgroundColor3 = Color3.fromRGB(25, 45, 85)
                button.TextColor3 = Color3.fromRGB(170, 220, 255)
            end
        end)
        
        petButtons[petName] = button
        return button
    end
    
    for _, petName in ipairs(petList) do
        createPetButton(petName)
    end
    
    task.spawn(function()
        while popupContent.Parent do
            task.wait(0.5)
            local contentSize = gridLayout.AbsoluteContentSize
            popupContent.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
        end
    end)
    
    placeholderInput:GetPropertyChangedSignal("Text"):Connect(function()
        local searchText = placeholderInput.Text:lower()
        for petName, button in pairs(petButtons) do
            if searchText == "" or petName:lower():find(searchText) then
                button.Visible = true
            else
                button.Visible = false
            end
        end
    end)
    
    selectAllButton.MouseButton1Click:Connect(function()
        if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
        for petName, button in pairs(petButtons) do
            Settings.BlacklistedPets[petName] = true
            button.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
        saveSettings()
    end)
    
    clearAllButton.MouseButton1Click:Connect(function()
        if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
        for petName, button in pairs(petButtons) do
            Settings.BlacklistedPets[petName] = false
            button.BackgroundColor3 = Color3.fromRGB(25, 45, 85)
            button.TextColor3 = Color3.fromRGB(170, 220, 255)
        end
        saveSettings()
    end)
    
    popupCloseButton.MouseButton1Click:Connect(function()
        if popupContainer and popupContainer.Parent then
            popupContainer:Destroy()
        end
        openPopups[popupName] = nil
    end)
    
    local popupDragging = false
    local popupDragStart = nil
    local popupStartPos = nil
    
    local function updatePopupInput(input)
        local delta = input.Position - popupDragStart
        local newPos = UDim2.new(
            popupStartPos.X.Scale,
            popupStartPos.X.Offset + delta.X,
            popupStartPos.Y.Scale,
            popupStartPos.Y.Offset + delta.Y
        )
        popupContainer.Position = newPos
    end
    
    local function onPopupDragStart(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            popupDragging = true
            popupDragStart = input.Position
            popupStartPos = popupContainer.Position
            
            if popupContainer.AnchorPoint ~= Vector2.new(0, 0) then
                local currentPos = popupContainer.Position
                local screenSize = workspace.CurrentCamera.ViewportSize
                local newX = currentPos.X.Offset + (currentPos.X.Scale * screenSize.X) - (popupContainer.Size.X.Offset / 2)
                local newY = currentPos.Y.Offset + (currentPos.Y.Scale * screenSize.Y) - (popupContainer.Size.Y.Offset / 2)
                popupContainer.AnchorPoint = Vector2.new(0, 0)
                popupContainer.Position = UDim2.new(0, newX, 0, newY)
                popupStartPos = popupContainer.Position
            end
            
            local connection
            connection = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    popupDragging = false
                    savePopupPosition(popupName, popupContainer.Position)
                    connection:Disconnect()
                end
            end)
        end
    end
    
    local function onPopupDrag(input)
        if popupDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updatePopupInput(input)
        end
    end
    
    popupHeader.InputBegan:Connect(onPopupDragStart)
    popupHeader.InputChanged:Connect(onPopupDrag)
    titleLabel.InputBegan:Connect(onPopupDragStart)
    titleLabel.InputChanged:Connect(onPopupDrag)
    
    addHoverAnimation(selectAllButton)
    addHoverAnimation(clearAllButton)
    
    return popupContainer, popupContent
end

-- Function to create Priority List GUI (Bright Blue Theme)
local function togglePriorityListPopup()
    local popupName = "JoinListPopup"
    local existingPopup = screenGui:FindFirstChild(popupName)
    
    if existingPopup then
        existingPopup:Destroy()
        openPopups[popupName] = nil
        return nil, nil
    end
    
    -- Create popup container
    local popupContainer = Instance.new("Frame")
    popupContainer.Name = popupName
    popupContainer.Size = UDim2.new(0, 420, 0, 480)
    
    local savedPopupPos = loadPopupPosition(popupName)
    if savedPopupPos then
        popupContainer.Position = savedPopupPos
        popupContainer.AnchorPoint = Vector2.new(0, 0)
    else
        popupContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
        popupContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    end
    
    popupContainer.BackgroundColor3 = Color3.fromRGB(15, 25, 45) -- Dark Blue
    popupContainer.BackgroundTransparency = 0.05
    popupContainer.BorderSizePixel = 0
    popupContainer.ZIndex = 20
    popupContainer.Parent = screenGui
    
    local popupCorner = Instance.new("UICorner")
    popupCorner.CornerRadius = UDim.new(0, 15)
    popupCorner.Parent = popupContainer
    
    -- Bright blue border
    local popupBorder = Instance.new("UIStroke")
    popupBorder.Color = Color3.fromRGB(80, 180, 255) -- Bright Blue
    popupBorder.Thickness = 4
    popupBorder.Transparency = 0.15
    popupBorder.Parent = popupContainer
    
    -- Header (Bright Blue)
    local popupHeader = Instance.new("Frame")
    popupHeader.Name = "PopupHeader"
    popupHeader.Size = UDim2.new(1, 0, 0, 50)
    popupHeader.Position = UDim2.new(0, 0, 0, 0)
    popupHeader.BackgroundColor3 = Color3.fromRGB(30, 60, 100) -- Bright Blue
    popupHeader.BackgroundTransparency = 0.1
    popupHeader.BorderSizePixel = 0
    popupHeader.ZIndex = 21
    popupHeader.Parent = popupContainer
    
    local popupHeaderCorner = Instance.new("UICorner")
    popupHeaderCorner.CornerRadius = UDim.new(0, 15)
    popupHeaderCorner.Parent = popupHeader
    
    -- Bright blue gradient effect
    local gradientTop = Instance.new("Frame")
    gradientTop.Name = "GradientTop"
    gradientTop.Size = UDim2.new(1, 0, 0, 4)
    gradientTop.Position = UDim2.new(0, 0, 0, 0)
    gradientTop.BackgroundColor3 = Color3.fromRGB(100, 200, 255) -- Bright Blue
    gradientTop.BackgroundTransparency = 0.3
    gradientTop.BorderSizePixel = 0
    gradientTop.ZIndex = 22
    gradientTop.Parent = popupHeader
    
    -- Title label
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, -75, 1, 0)
    titleLabel.Position = UDim2.new(0, 20, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "‚≠ê PRIORITY LIST"
    titleLabel.TextColor3 = Color3.fromRGB(150, 220, 255) -- Bright Blue
    titleLabel.TextSize = 24
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextYAlignment = Enum.TextYAlignment.Center
    titleLabel.ZIndex = 23
    titleLabel.Parent = popupHeader
    
    -- Close button
    local popupCloseButton = Instance.new("TextButton")
    popupCloseButton.Name = "PopupCloseButton"
    popupCloseButton.Size = UDim2.new(0, 38, 0, 38)
    popupCloseButton.Position = UDim2.new(1, -42, 0.5, 0)
    popupCloseButton.AnchorPoint = Vector2.new(0, 0.5)
    popupCloseButton.BackgroundColor3 = Color3.fromRGB(30, 60, 120) -- Bright Blue
    popupCloseButton.BackgroundTransparency = 0.15
    popupCloseButton.BorderSizePixel = 0
    popupCloseButton.Text = "‚úï"
    popupCloseButton.TextColor3 = Color3.fromRGB(180, 240, 255) -- Very Light Blue
    popupCloseButton.TextSize = 22
    popupCloseButton.Font = Enum.Font.GothamBold
    popupCloseButton.ZIndex = 24
    popupCloseButton.Parent = popupHeader
    
    local popupCloseCorner = Instance.new("UICorner")
    popupCloseCorner.CornerRadius = UDim.new(0, 10)
    popupCloseCorner.Parent = popupCloseButton
    
    -- Search input field
    local placeholderInput = Instance.new("TextBox")
    placeholderInput.Name = "PlaceholderInput"
    placeholderInput.Size = UDim2.new(1, -20, 0, 38)
    placeholderInput.Position = UDim2.new(0, 10, 0, 60)
    placeholderInput.BackgroundColor3 = Color3.fromRGB(25, 45, 85) -- Dark Blue
    placeholderInput.BackgroundTransparency = 0.2
    placeholderInput.BorderSizePixel = 0
    placeholderInput.Text = ""
    placeholderInput.PlaceholderText = "‚ú® Search priority pets..."
    placeholderInput.PlaceholderColor3 = Color3.fromRGB(120, 180, 220) -- Blue tinted gray
    placeholderInput.TextColor3 = Color3.fromRGB(200, 240, 255) -- Very Light Blue
    placeholderInput.TextSize = 15
    placeholderInput.Font = Enum.Font.GothamBold
    placeholderInput.TextXAlignment = Enum.TextXAlignment.Left
    placeholderInput.ClearTextOnFocus = false
    placeholderInput.Parent = popupContainer
    
    local placeholderCorner = Instance.new("UICorner")
    placeholderCorner.CornerRadius = UDim.new(0, 10)
    placeholderCorner.Parent = placeholderInput
    
    -- Buttons container
    local buttonsContainer = Instance.new("Frame")
    buttonsContainer.Name = "ButtonsContainer"
    buttonsContainer.Size = UDim2.new(1, -20, 0, 38)
    buttonsContainer.Position = UDim2.new(0, 10, 0, 106)
    buttonsContainer.BackgroundTransparency = 1
    buttonsContainer.Parent = popupContainer
    
    -- Select All button
    local selectAllButton = Instance.new("TextButton")
    selectAllButton.Name = "SelectAllButton"
    selectAllButton.Size = UDim2.new(0.48, 0, 1, 0)
    selectAllButton.Position = UDim2.new(0, 0, 0, 0)
    selectAllButton.BackgroundColor3 = Color3.fromRGB(30, 60, 120) -- Bright Blue
    selectAllButton.BackgroundTransparency = 0.2
    selectAllButton.BorderSizePixel = 0
    selectAllButton.Text = "‚≠ê Select All"
    selectAllButton.TextColor3 = Color3.fromRGB(200, 240, 255) -- Very Light Blue
    selectAllButton.TextSize = 14
    selectAllButton.Font = Enum.Font.GothamBold
    selectAllButton.Parent = buttonsContainer
    
    local selectAllCorner = Instance.new("UICorner")
    selectAllCorner.CornerRadius = UDim.new(0, 8)
    selectAllCorner.Parent = selectAllButton
    
    -- Clear All button
    local clearAllButton = Instance.new("TextButton")
    clearAllButton.Name = "ClearAllButton"
    clearAllButton.Size = UDim2.new(0.48, 0, 1, 0)
    clearAllButton.Position = UDim2.new(0.52, 0, 0, 0)
    clearAllButton.BackgroundColor3 = Color3.fromRGB(40, 80, 140) -- Darker Blue
    clearAllButton.BackgroundTransparency = 0.2
    clearAllButton.BorderSizePixel = 0
    clearAllButton.Text = "Clear All"
    clearAllButton.TextColor3 = Color3.fromRGB(170, 220, 255) -- Light Blue
    clearAllButton.TextSize = 14
    clearAllButton.Font = Enum.Font.GothamBold
    clearAllButton.Parent = buttonsContainer
    
    local clearAllCorner = Instance.new("UICorner")
    clearAllCorner.CornerRadius = UDim.new(0, 8)
    clearAllCorner.Parent = clearAllButton
    
    -- Content area
    local popupContent = Instance.new("ScrollingFrame")
    popupContent.Name = "PopupContent"
    popupContent.Size = UDim2.new(1, -12, 1, -160)
    popupContent.Position = UDim2.new(0, 10, 0, 152)
    popupContent.BackgroundTransparency = 1
    popupContent.BorderSizePixel = 0
    popupContent.ScrollBarThickness = 10
    popupContent.ScrollBarImageColor3 = Color3.fromRGB(100, 200, 255) -- Bright Blue scrollbar
    popupContent.CanvasSize = UDim2.new(0, 0, 0, 0)
    popupContent.Parent = popupContainer
    
    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0, 188, 0, 35)
    gridLayout.CellPadding = UDim2.new(0, 8, 0, 8)
    gridLayout.SortOrder = Enum.SortOrder.Name
    gridLayout.Parent = popupContent
    
    local petList = getPetList()
    local settings = getEliteSettings()
    if settings.PriorityPets and type(settings.PriorityPets) == "table" then 
        Settings.PriorityPets = settings.PriorityPets 
    end
    if not Settings.PriorityPets or type(Settings.PriorityPets) ~= "table" then
        Settings.PriorityPets = {}
    end
    local petButtons = {}
    
    local function createPetButton(petName)
        local button = Instance.new("TextButton")
        button.Name = petName
        button.BackgroundColor3 = Color3.fromRGB(25, 45, 85) -- Dark Blue
        button.BackgroundTransparency = 0.25
        button.Text = petName
        button.TextColor3 = Color3.fromRGB(170, 220, 255) -- Light Blue
        button.TextSize = 13
        button.Font = Enum.Font.GothamBold
        button.BorderSizePixel = 0
        button.TextXAlignment = Enum.TextXAlignment.Center
        button.TextTruncate = Enum.TextTruncate.AtEnd
        button.Parent = popupContent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = button
        
        local isSelected = Settings.PriorityPets and Settings.PriorityPets[petName] == true
        
        if isSelected then
            button.BackgroundColor3 = Color3.fromRGB(80, 180, 255) -- Bright Blue when selected
            button.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
        end
        
        button.MouseButton1Click:Connect(function()
            isSelected = not isSelected
            
            if not Settings.PriorityPets then Settings.PriorityPets = {} end
            Settings.PriorityPets[petName] = isSelected
            
            saveSettings()
            
            if isSelected then
                button.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
            else
                button.BackgroundColor3 = Color3.fromRGB(25, 45, 85)
                button.TextColor3 = Color3.fromRGB(170, 220, 255)
            end
        end)
        
        petButtons[petName] = button
        return button
    end
    
    for _, petName in ipairs(petList) do
        createPetButton(petName)
    end
    
    task.spawn(function()
        while popupContent.Parent do
            task.wait(0.5)
            local contentSize = gridLayout.AbsoluteContentSize
            popupContent.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
        end
    end)
    
    placeholderInput:GetPropertyChangedSignal("Text"):Connect(function()
        local searchText = placeholderInput.Text:lower()
        for petName, button in pairs(petButtons) do
            if searchText == "" or petName:lower():find(searchText) then
                button.Visible = true
            else
                button.Visible = false
            end
        end
    end)
    
    selectAllButton.MouseButton1Click:Connect(function()
        if not Settings.PriorityPets then Settings.PriorityPets = {} end
        for petName, button in pairs(petButtons) do
            Settings.PriorityPets[petName] = true
            button.BackgroundColor3 = Color3.fromRGB(80, 180, 255)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
        saveSettings()
    end)
    
    clearAllButton.MouseButton1Click:Connect(function()
        if not Settings.PriorityPets then Settings.PriorityPets = {} end
        for petName, button in pairs(petButtons) do
            Settings.PriorityPets[petName] = false
            button.BackgroundColor3 = Color3.fromRGB(25, 45, 85)
            button.TextColor3 = Color3.fromRGB(170, 220, 255)
        end
        saveSettings()
    end)
    
    popupCloseButton.MouseButton1Click:Connect(function()
        if popupContainer and popupContainer.Parent then
            popupContainer:Destroy()
        end
        openPopups[popupName] = nil
    end)
    
    local popupDragging = false
    local popupDragStart = nil
    local popupStartPos = nil
    
    local function updatePopupInput(input)
        local delta = input.Position - popupDragStart
        local newPos = UDim2.new(
            popupStartPos.X.Scale,
            popupStartPos.X.Offset + delta.X,
            popupStartPos.Y.Scale,
            popupStartPos.Y.Offset + delta.Y
        )
        popupContainer.Position = newPos
    end
    
    local function onPopupDragStart(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            popupDragging = true
            popupDragStart = input.Position
            popupStartPos = popupContainer.Position
            
            if popupContainer.AnchorPoint ~= Vector2.new(0, 0) then
                local currentPos = popupContainer.Position
                local screenSize = workspace.CurrentCamera.ViewportSize
                local newX = currentPos.X.Offset + (currentPos.X.Scale * screenSize.X) - (popupContainer.Size.X.Offset / 2)
                local newY = currentPos.Y.Offset + (currentPos.Y.Scale * screenSize.Y) - (popupContainer.Size.Y.Offset / 2)
                popupContainer.AnchorPoint = Vector2.new(0, 0)
                popupContainer.Position = UDim2.new(0, newX, 0, newY)
                popupStartPos = popupContainer.Position
            end
            
            local connection
            connection = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    popupDragging = false
                    savePopupPosition(popupName, popupContainer.Position)
                    connection:Disconnect()
                end
            end)
        end
    end
    
    local function onPopupDrag(input)
        if popupDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updatePopupInput(input)
        end
    end
    
    popupHeader.InputBegan:Connect(onPopupDragStart)
    popupHeader.InputChanged:Connect(onPopupDrag)
    titleLabel.InputBegan:Connect(onPopupDragStart)
    titleLabel.InputChanged:Connect(onPopupDrag)
    
    addHoverAnimation(selectAllButton)
    addHoverAnimation(clearAllButton)
    
    return popupContainer, popupContent
end

-- Old function kept for compatibility
local function togglePopupWindow(popupName, title, isPriorityList)
    -- Check if popup is already open
    local existingPopup = screenGui:FindFirstChild(popupName)
    
    if existingPopup then
        -- Close the popup
        existingPopup:Destroy()
        openPopups[popupName] = nil
        return nil, nil
    end
    
    -- Create new popup
    
    -- Create popup container
    local popupContainer = Instance.new("Frame")
    popupContainer.Name = popupName
    popupContainer.Size = UDim2.new(0, 375, 0, 400)
    
    -- Load saved position or use default
    local savedPopupPos = loadPopupPosition(popupName)
    if savedPopupPos then
        popupContainer.Position = savedPopupPos
        popupContainer.AnchorPoint = Vector2.new(0, 0) -- Change anchor point for saved positions
    else
        popupContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
        popupContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    end
    
    popupContainer.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue
    popupContainer.BackgroundTransparency = 0.2
    popupContainer.BorderSizePixel = 0
    popupContainer.ZIndex = 20
    popupContainer.Parent = screenGui
    
    -- Round corners
    local popupCorner = Instance.new("UICorner")
    popupCorner.CornerRadius = UDim.new(0, 10)
    popupCorner.Parent = popupContainer
    
    -- Header
    local popupHeader = Instance.new("Frame")
    popupHeader.Name = "PopupHeader"
    popupHeader.Size = UDim2.new(1, 0, 0, 38)
    popupHeader.Position = UDim2.new(0, 0, 0, 0)
    popupHeader.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue
    popupHeader.BackgroundTransparency = 0.2
    popupHeader.BorderSizePixel = 0
    popupHeader.ZIndex = 21
    popupHeader.Parent = popupContainer
    
    local popupHeaderCorner = Instance.new("UICorner")
    popupHeaderCorner.CornerRadius = UDim.new(0, 10)
    popupHeaderCorner.Parent = popupHeader
    
    -- Title label
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, -60, 1, 0)
    titleLabel.Position = UDim2.new(0, 20, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
    titleLabel.TextSize = 21
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Center
    titleLabel.TextYAlignment = Enum.TextYAlignment.Center
    titleLabel.Parent = popupHeader
    
    -- Close button
    local popupCloseButton = Instance.new("TextButton")
    popupCloseButton.Name = "PopupCloseButton"
    popupCloseButton.Size = UDim2.new(0, 30, 0, 30)
    popupCloseButton.Position = UDim2.new(1, -34, 0.5, 0)
    popupCloseButton.AnchorPoint = Vector2.new(0, 0.5)
    popupCloseButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue
    popupCloseButton.BackgroundTransparency = 0.2
    popupCloseButton.BorderSizePixel = 0
    popupCloseButton.Text = "X"
    popupCloseButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
    popupCloseButton.TextSize = 18
    popupCloseButton.Font = Enum.Font.GothamBold
    popupCloseButton.ZIndex = 22
    popupCloseButton.Parent = popupHeader
    
    local popupCloseCorner = Instance.new("UICorner")
    popupCloseCorner.CornerRadius = UDim.new(1, 0)
    popupCloseCorner.Parent = popupCloseButton
    
    -- Search input field
    local placeholderInput = Instance.new("TextBox")
    placeholderInput.Name = "PlaceholderInput"
    placeholderInput.Size = UDim2.new(1, -15, 0, 30)
    placeholderInput.Position = UDim2.new(0, 8, 0, 45)
    placeholderInput.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue
    placeholderInput.BackgroundTransparency = 0.2
    placeholderInput.BorderSizePixel = 0
    placeholderInput.Text = ""
    placeholderInput.PlaceholderText = "üîé Search pets..."
    placeholderInput.PlaceholderColor3 = Color3.fromRGB(200, 200, 200) -- Light gray placeholder
    placeholderInput.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
    placeholderInput.TextSize = 14
    placeholderInput.Font = Enum.Font.GothamBold
    placeholderInput.TextXAlignment = Enum.TextXAlignment.Center
    placeholderInput.ClearTextOnFocus = false
    placeholderInput.Parent = popupContainer
    
    local placeholderCorner = Instance.new("UICorner")
    placeholderCorner.CornerRadius = UDim.new(0, 8)
    placeholderCorner.Parent = placeholderInput
    
    -- Buttons container
    local buttonsContainer = Instance.new("Frame")
    buttonsContainer.Name = "ButtonsContainer"
    buttonsContainer.Size = UDim2.new(1, -15, 0, 30)
    buttonsContainer.Position = UDim2.new(0, 8, 0, 83)
    buttonsContainer.BackgroundTransparency = 1
    buttonsContainer.Parent = popupContainer
    
    -- Select All button
    local selectAllButton = Instance.new("TextButton")
    selectAllButton.Name = "SelectAllButton"
    selectAllButton.Size = UDim2.new(0.48, 0, 1, 0)
    selectAllButton.Position = UDim2.new(0, 0, 0, 0)
    selectAllButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue
    selectAllButton.BackgroundTransparency = 0.2
    selectAllButton.BorderSizePixel = 0
    selectAllButton.Text = "Select All"
    selectAllButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
    selectAllButton.TextSize = 14
    selectAllButton.Font = Enum.Font.GothamBold
    selectAllButton.Parent = buttonsContainer
    
    local selectAllCorner = Instance.new("UICorner")
    selectAllCorner.CornerRadius = UDim.new(0, 8)
    selectAllCorner.Parent = selectAllButton
    
    -- Clear All button
    local clearAllButton = Instance.new("TextButton")
    clearAllButton.Name = "ClearAllButton"
    clearAllButton.Size = UDim2.new(0.48, 0, 1, 0)
    clearAllButton.Position = UDim2.new(0.52, 0, 0, 0)
    clearAllButton.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue
    clearAllButton.BackgroundTransparency = 0.2
    clearAllButton.BorderSizePixel = 0
    clearAllButton.Text = "Clear All"
    clearAllButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
    clearAllButton.TextSize = 14
    clearAllButton.Font = Enum.Font.GothamBold
    clearAllButton.Parent = buttonsContainer
    
    local clearAllCorner = Instance.new("UICorner")
    clearAllCorner.CornerRadius = UDim.new(0, 8)
    clearAllCorner.Parent = clearAllButton
    
    -- Content area (scrollable)
    local popupContent = Instance.new("ScrollingFrame")
    popupContent.Name = "PopupContent"
    popupContent.Size = UDim2.new(1, -15, 1, -120)
    popupContent.Position = UDim2.new(0, 8, 0, 120)
    popupContent.BackgroundTransparency = 1
    popupContent.BorderSizePixel = 0
    popupContent.ScrollBarThickness = 8
    popupContent.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255) -- White scrollbar
    popupContent.CanvasSize = UDim2.new(0, 0, 0, 0)
    popupContent.Parent = popupContainer
    
    -- Grid layout for pet buttons
    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0, 160, 0, 30)
    gridLayout.CellPadding = UDim2.new(0, 5, 0, 5)
    gridLayout.SortOrder = Enum.SortOrder.Name
    gridLayout.Parent = popupContent
    
    -- Get pet list and settings
    local petList = getPetList()
    -- Use local Settings object, sync with file
    local settings = getEliteSettings()
    -- Sync Settings with loaded settings
    if settings.PriorityPets and type(settings.PriorityPets) == "table" then 
        Settings.PriorityPets = settings.PriorityPets 
    end
    if not Settings.PriorityPets or type(Settings.PriorityPets) ~= "table" then
        Settings.PriorityPets = {}
    end
    if settings.BlacklistedPets and type(settings.BlacklistedPets) == "table" then 
        Settings.BlacklistedPets = settings.BlacklistedPets 
    end
    if not Settings.BlacklistedPets or type(Settings.BlacklistedPets) ~= "table" then
        Settings.BlacklistedPets = {}
    end
    local petButtons = {}
    
    -- Create pet buttons
    local function createPetButton(petName)
        local button = Instance.new("TextButton")
        button.Name = petName
        button.BackgroundColor3 = Color3.fromRGB(50, 150, 255) -- Blue
        button.BackgroundTransparency = 0.2
        button.Text = petName
        button.TextColor3 = Color3.fromRGB(255, 255, 255) -- White
        button.TextSize = 12
        button.Font = Enum.Font.GothamBold
        button.BorderSizePixel = 0
        button.TextXAlignment = Enum.TextXAlignment.Center
        button.TextTruncate = Enum.TextTruncate.AtEnd
        button.Parent = popupContent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = button
        
        -- Check if pet is selected
        local isSelected = false
        if isPriorityList then
            isSelected = Settings.PriorityPets and Settings.PriorityPets[petName] == true
        else
            isSelected = Settings.BlacklistedPets and Settings.BlacklistedPets[petName] == true
        end
        
        if isSelected then
            button.BackgroundTransparency = 0.1 -- Less transparent when selected
        end
        
        button.MouseButton1Click:Connect(function()
            -- Toggle selection
            isSelected = not isSelected
            
            -- Update Settings object directly
            if isPriorityList then
                if not Settings.PriorityPets then Settings.PriorityPets = {} end
                Settings.PriorityPets[petName] = isSelected
            else
                if not Settings.BlacklistedPets then Settings.BlacklistedPets = {} end
                Settings.BlacklistedPets[petName] = isSelected
            end
            
            -- Save to file
            saveSettings()
            
            -- Update button appearance
            if isSelected then
                button.BackgroundTransparency = 0.1
            else
                button.BackgroundTransparency = 0.2
            end
        end)
        
        petButtons[petName] = button
        return button
    end
    
    -- Create buttons for all pets
    for _, petName in ipairs(petList) do
        createPetButton(petName)
    end
    
    -- Update canvas size
    task.spawn(function()
        while popupContent.Parent do
            task.wait(0.5)
            local contentSize = gridLayout.AbsoluteContentSize
            popupContent.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
        end
    end)
    
    -- Search functionality
    placeholderInput:GetPropertyChangedSignal("Text"):Connect(function()
        local searchText = placeholderInput.Text:lower()
        for petName, button in pairs(petButtons) do
            if searchText == "" or petName:lower():find(searchText) then
                button.Visible = true
            else
                button.Visible = false
            end
        end
    end)
    
    -- Select All functionality
    selectAllButton.MouseButton1Click:Connect(function()
        local targetSettings = isPriorityList and Settings.PriorityPets or Settings.BlacklistedPets
        if not targetSettings then
            if isPriorityList then
                Settings.PriorityPets = {}
            else
                Settings.BlacklistedPets = {}
            end
            targetSettings = isPriorityList and Settings.PriorityPets or Settings.BlacklistedPets
        end
        
        for petName, button in pairs(petButtons) do
            targetSettings[petName] = true
            button.BackgroundTransparency = 0.1
        end
        
        -- Save to file
        saveSettings()
    end)
    
    -- Clear All functionality
    clearAllButton.MouseButton1Click:Connect(function()
        local targetSettings = isPriorityList and Settings.PriorityPets or Settings.BlacklistedPets
        if not targetSettings then
            if isPriorityList then
                Settings.PriorityPets = {}
            else
                Settings.BlacklistedPets = {}
            end
            targetSettings = isPriorityList and Settings.PriorityPets or Settings.BlacklistedPets
        end
        
        for petName, button in pairs(petButtons) do
            targetSettings[petName] = false
            button.BackgroundTransparency = 0.2
        end
        
        -- Save to file
        saveSettings()
    end)
    
    -- Close button functionality
    popupCloseButton.MouseButton1Click:Connect(function()
        if popupContainer and popupContainer.Parent then
            popupContainer:Destroy()
        end
        openPopups[popupName] = nil
    end)
    
    -- Set initial size
    popupContainer.Size = UDim2.new(0, 375, 0, 400)
    
    -- Drag functionality for popup
    local popupDragging = false
    local popupDragStart = nil
    local popupStartPos = nil
    
    local function updatePopupInput(input)
        local delta = input.Position - popupDragStart
        local newPos = UDim2.new(
            popupStartPos.X.Scale,
            popupStartPos.X.Offset + delta.X,
            popupStartPos.Y.Scale,
            popupStartPos.Y.Offset + delta.Y
        )
        popupContainer.Position = newPos
    end
    
    local function onPopupDragStart(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            popupDragging = true
            popupDragStart = input.Position
            popupStartPos = popupContainer.Position
            
            -- Update anchor point if needed (convert from center to top-left)
            if popupContainer.AnchorPoint ~= Vector2.new(0, 0) then
                local currentPos = popupContainer.Position
                local screenSize = workspace.CurrentCamera.ViewportSize
                local newX = currentPos.X.Offset + (currentPos.X.Scale * screenSize.X) - (popupContainer.Size.X.Offset / 2)
                local newY = currentPos.Y.Offset + (currentPos.Y.Scale * screenSize.Y) - (popupContainer.Size.Y.Offset / 2)
                popupContainer.AnchorPoint = Vector2.new(0, 0)
                popupContainer.Position = UDim2.new(0, newX, 0, newY)
                popupStartPos = popupContainer.Position
            end
            
            local connection
            connection = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    popupDragging = false
                    -- Save position when drag ends
                    savePopupPosition(popupName, popupContainer.Position)
                    connection:Disconnect()
                end
            end)
        end
    end
    
    local function onPopupDrag(input)
        if popupDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updatePopupInput(input)
        end
    end
    
    -- Make popup draggable from header
    popupHeader.InputBegan:Connect(onPopupDragStart)
    popupHeader.InputChanged:Connect(onPopupDrag)
    titleLabel.InputBegan:Connect(onPopupDragStart)
    titleLabel.InputChanged:Connect(onPopupDrag)
    
    -- Add hover animations to buttons
    addHoverAnimation(selectAllButton)
    addHoverAnimation(clearAllButton)
    
    return popupContainer, popupContent
end

-- Button handlers are already set up via Slixx callbacks above

-- Format pet value (matching elite.lua)
local function formatPetValue(value)
    if value >= 1000000000 then
        return string.format("$%.1fB/s", value / 1000000000)
    elseif value >= 1000000 then
        return string.format("$%.1fM/s", value / 1000000)
    else
        return string.format("$%.0f/s", value)
    end
end

-- Clear job function (from elite.lua) - Must be defined before joinServerWithRetries
local function clearJob(serverId)
    pcall(function()
        -- Try WebSocket first
        if wsConnection and wsConnected and useWebSocket then
            local clearMsg = HttpService:JSONEncode({
                type = "clear_job",
                client_id = CLIENT_ID,
                server_id = serverId
            })
            
            local sendSuccess = false
            if wsConnection.Send then
                sendSuccess = pcall(function() wsConnection:Send(clearMsg) end)
            elseif wsConnection.send then
                sendSuccess = pcall(function() wsConnection:send(clearMsg) end)
            elseif wsConnection.write then
                sendSuccess = pcall(function() wsConnection:write(clearMsg) end)
            end
            
            if not sendSuccess then
                -- Fallback to HTTP if WebSocket send fails
                local url = API_URL .. "/clear_job?client_id=" .. HttpService:UrlEncode(CLIENT_ID)
                if serverId then
                    url = url .. "&server_id=" .. HttpService:UrlEncode(serverId)
                end
                game:HttpPost(url, "{}", true, "application/json")
            end
        else
            -- Fallback to HTTP
            local url = API_URL .. "/clear_job?client_id=" .. HttpService:UrlEncode(CLIENT_ID)
            if serverId then
                url = url .. "&server_id=" .. HttpService:UrlEncode(serverId)
            end
            game:HttpPost(url, "{}", true, "application/json")
        end
    end)
end

-- Join server with retries (from elite.lua) - Must be defined before addLog
local function joinServerWithRetries(serverId, gui, allowRejoin)
    -- Note: gui can be nil for Aether Elite (it doesn't have StopButton/StatusLabel)
    
    -- Convert to string for comparison
    local currentJobId = tostring(game.JobId)
    local targetServerId = tostring(serverId)
    
    -- Check if already in this server (unless allowRejoin is true for manual clicks)
    if currentJobId == targetServerId then
        if not allowRejoin then
            print("[Join] ‚ö†Ô∏è Already in server " .. targetServerId .. ", skipping join")
            return false
        else
            print("[Join] ‚ÑπÔ∏è Already in server " .. targetServerId .. ", but allowing rejoin (manual click)")
        end
    end
    
    -- Clear processedServers when joining a different server
    if currentJobId ~= targetServerId then
        -- Clear old processed servers to allow rejoining them later
        processedServers = {}
    end
    
    -- Don't join if already marked as processed (unless manual click)
    if processedServers[serverId] and not allowRejoin then 
        return false 
    end
    
    -- Mark as processed only if not a manual rejoin
    if not allowRejoin then
        processedServers[serverId] = true
    end
    
    currentlyJoining = true
    stopJoining = false
    
    -- Show stop button and update status
    if gui and gui.StopButton then
        gui.StopButton.Visible = true
    end
    -- Change main button to STOP status when joining (for Aether Elite when gui is nil)
    if not gui then
        dotState = true
        if statusDot then
            statusDot.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Green
        end
        if startAjoButton then
            startAjoButton.Text = "‚è∏ STOP"
        end
    end
    if gui and gui.StatusLabel then
        gui.StatusLabel.Text = "Status: Joining Server..."
        gui.StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 50)
    end
    
    local currentRetries = Settings.Retries
    local currentDelay = Settings.RetryDelay
    
    for attempt = 1, currentRetries do
        if stopJoining then
            if gui and gui.StopButton then
                gui.StopButton.Visible = false
            end
            if gui and gui.StatusLabel then
                gui.StatusLabel.Text = Settings.Enabled and "Status: Active" or "Status: Disabled"
                gui.StatusLabel.TextColor3 = Settings.Enabled and Color3.fromRGB(100, 255, 150) or Color3.fromRGB(255, 100, 100)
            end
            -- Restore START button status when stopped
            if not gui then
                dotState = false
                if statusDot then
                    statusDot.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red
                end
                if startAjoButton then
                    startAjoButton.Text = "‚ñ∂ START"
                end
            end
            currentlyJoining = false
            return false
        end
        
        -- Update status with attempt number
        if gui and gui.StatusLabel then
            gui.StatusLabel.Text = string.format("Status: Join Attempt %d/%d", attempt, currentRetries)
            gui.StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 50)
        end
        
        pcall(function()
            TeleportService:TeleportToPlaceInstance(GAME_ID, serverId, Players.LocalPlayer)
        end)
        
        if attempt < currentRetries then
            task.wait(currentDelay)
            if stopJoining then
                if gui and gui.StopButton then
                    gui.StopButton.Visible = false
                end
                if gui and gui.StatusLabel then
                    gui.StatusLabel.Text = Settings.Enabled and "Status: Active" or "Status: Disabled"
                    gui.StatusLabel.TextColor3 = Settings.Enabled and Color3.fromRGB(100, 255, 150) or Color3.fromRGB(255, 100, 100)
                end
                -- Restore START button status when stopped
                if not gui then
                    dotState = false
                    if statusDot then
                        statusDot.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red
                    end
                    if startAjoButton then
                        startAjoButton.Text = "‚ñ∂ START"
                    end
                end
                currentlyJoining = false
                return false
            end
        end
    end
    
    -- Hide stop button and restore status after joining finishes
    if gui and gui.StopButton then
        gui.StopButton.Visible = false
    end
    if gui and gui.StatusLabel then
        gui.StatusLabel.Text = Settings.Enabled and "Status: Active" or "Status: Disabled"
        gui.StatusLabel.TextColor3 = Settings.Enabled and Color3.fromRGB(100, 255, 150) or Color3.fromRGB(255, 100, 100)
    end
    
    clearJob(serverId)
    currentlyJoining = false
    
    -- Restore START button status when joining finishes (for Aether Elite when gui is nil)
    if not gui then
        dotState = false
        if statusDot then
            statusDot.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red
        end
        if startAjoButton then
            startAjoButton.Text = "‚ñ∂ START"
        end
    end
    
    -- Clear processedServers after successful join attempt to allow rejoining servers later
    task.wait(2)
    
    -- Verify we actually changed servers
    if tostring(game.JobId) == targetServerId then
        print("[Join] ‚úÖ Successfully joined server " .. targetServerId)
        -- Clear processed servers when we successfully join a new server
        processedServers = {}
    end
    
    return true
end

-- Add log to log GUI using Slixx's NewButton API (like PRIO tab buttons!)
local function addLog(petName, petValue, serverId, thumbnailUrl, gui, petValueFormatted, isPriority)
    -- Check if logsTab is available
    if not logsTab then
        warn("[Aether Elite] ‚ö†Ô∏è logsTab not available - log will not be displayed")
        return
    end
    
    -- Check if logsTab has NewButton method
    if not logsTab.NewButton or type(logsTab.NewButton) ~= "function" then
        warn("[Aether Elite] ‚ö†Ô∏è logsTab.NewButton not available - log will not be displayed")
        return
    end
    
    -- Ensure logDataStore exists
    if not logDataStore then
        logDataStore = {}
    end
    
    print("[Aether Elite] üìù Adding log:", petName, "Value:", petValueFormatted or formatPetValue(petValue), "Server:", serverId)
    
    -- Prevent duplicate logs for the same server (check both logButtons and logDataStore)
    if logButtons and logButtons[serverId] then
        print("[Aether Elite] ‚ÑπÔ∏è Log button for server", serverId, "already exists, skipping duplicate.")
        return
    end
    
    if logDataStore and logDataStore[serverId] then
        print("[Aether Elite] ‚ÑπÔ∏è Log data for server", serverId, "already exists, skipping duplicate.")
        return
    end
    
    -- Format log text
    local logText = petName .. " - " .. (petValueFormatted or formatPetValue(petValue))
    
    -- Check if GUI is minimized - if so, don't open it, just add log silently
    local scriptedUI = game:GetService("CoreGui"):FindFirstChild("ScriptedUI")
    if not scriptedUI then
        scriptedUI = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScriptedUI")
    end
    
    local isMinimized = scriptedUI and not scriptedUI.Enabled
    
    -- Ensure logsTab is ready (wait a tiny bit if needed)
    if not logsTab or not logsTab.NewButton then
        warn("[Aether Elite] ‚ö†Ô∏è logsTab not ready - waiting and retrying...")
        task.wait(0.1)
        if not logsTab or not logsTab.NewButton then
            warn("[Aether Elite] ‚ö†Ô∏è logsTab still not ready - log will not be displayed")
            return
        end
    end
    
    -- Use Slixx's NewButton API to add log button (just like PRIO tab buttons!)
    -- Call it directly like prioTab:NewButton does (no pcall needed, Slixx handles errors)
    local logButton = logsTab:NewButton(logText, function()
        print("[Aether Elite] üñ±Ô∏è Log button clicked for:", petName, "Server:", serverId)
        -- Reset stop flags when manually clicking to join
        stopJoining = false
        TELEPORT_BLOCKED = false
        currentlyJoining = true
        
        -- Change main button to STOP status
        dotState = true
        if statusDot then
        statusDot.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Green
        end
        if startAjoButton then
            local toggleText = startAjoButton:FindFirstChild("ToggleText")
            if toggleText then
                toggleText.Text = "‚è∏ STOP"
            end
        end
        
        task.spawn(function()
            -- Allow manual clicks to rejoin (for private servers)
            joinServerWithRetries(serverId, gui, true)
            
            -- Restore START button status when done
            task.spawn(function()
                while currentlyJoining do
                    task.wait(0.1)
                end
                -- Wait a bit more to ensure join is fully stopped
                task.wait(0.2)
                -- Restore to START status
                dotState = false
                if statusDot then
                statusDot.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Red
                end
                if startAjoButton then
                    local toggleText = startAjoButton:FindFirstChild("ToggleText")
                    if toggleText then
                        toggleText.Text = "‚ñ∂ START"
                    end
                end
            end)
        end)
    end)
    
    -- Make pet name text white by finding and modifying the button's text label
    task.spawn(function()
        -- Try multiple times to catch the button after Slixx creates it
        for i = 1, 5 do
            task.wait(0.2) -- Wait for Slixx to create the button
            
            -- Make all log text white (aggressive approach)
            makeAllLogTextWhite()
            
            -- Also try to find the specific button we just created
            if logsTab and logsTab.sectionBG then
                -- Find the button we just created by searching for the logText
                local foundButton = nil
                for _, descendant in pairs(logsTab.sectionBG:GetDescendants()) do
                    -- Check if this element contains our log text
                    if (descendant:IsA("TextLabel") or descendant:IsA("TextButton")) then
                        local text = descendant.Text or ""
                        if text == logText or text:find(petName, 1, true) or (logText and text:find(logText:sub(1, math.min(20, #logText)), 1, true)) then
                            foundButton = descendant
                            -- Make the text white
                            descendant.TextColor3 = Color3.fromRGB(255, 255, 255) -- Bright white
                            
                            -- Also check for all text children
                            for _, child in pairs(descendant:GetDescendants()) do
                                if child:IsA("TextLabel") then
                                    child.TextColor3 = Color3.fromRGB(255, 255, 255) -- Bright white
                                end
                            end
                            
                            -- Check for ToggleText child (Slixx might use this)
                            local toggleText = descendant:FindFirstChild("ToggleText", true)
                            if toggleText then
                                toggleText.TextColor3 = Color3.fromRGB(255, 255, 255) -- Bright white
                            end
                            
                            -- Also check parent if it's a TextButton
                            if descendant:IsA("TextButton") then
                                descendant.TextColor3 = Color3.fromRGB(255, 255, 255) -- Bright white
                            end
                            
                            break
                        end
                    end
                end
                
                -- If we found a button, also search for its parent container and make all text white
                if foundButton then
                    local parent = foundButton.Parent
                    if parent then
                        for _, child in pairs(parent:GetDescendants()) do
                            if child:IsA("TextLabel") then
                                child.TextColor3 = Color3.fromRGB(255, 255, 255) -- Bright white
                            elseif child:IsA("TextButton") and child.Text ~= "" then
                                child.TextColor3 = Color3.fromRGB(255, 255, 255) -- Bright white
                            end
                        end
                    end
                end
            end
        end
        
        -- Don't restore minimized state - logs can be added even when GUI is minimized
        -- They will appear when the user opens the GUI
    end)
    
    -- NewButton might return nil or a table/object - both are fine, button is still created
    -- Just store whatever it returns (or use a placeholder if nil)
    if not logButton then
        -- Button was created but NewButton returned nil - that's okay, Slixx handles it
        logButton = true -- Use a placeholder so we can track it
    end
    
    -- Ensure logButtons table exists
    if not logButtons then
        logButtons = {}
    end
    
    -- Store button reference
    logButtons[serverId] = logButton
    
    -- Store log data for restoration when GUI reopens
    logDataStore[serverId] = {
        petName = petName,
        petValue = petValue,
        serverId = serverId,
        thumbnailUrl = thumbnailUrl,
        gui = gui,
        petValueFormatted = petValueFormatted,
        isPriority = isPriority,
        createdAt = tick()
    }
    
    -- Add to active logs
    local logData = {
        button = logButton,
        serverId = serverId,
        createdAt = tick(),
        removeTimer = nil
    }
    table.insert(activeLogs, logData)
    
    -- Play notification sound
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://8853003751"
    sound.Volume = 0.3
    sound.Parent = game:GetService("SoundService")
    sound:Play()
    task.delay(2, function()
        sound:Destroy()
    end)
    
    -- Remove log after 30 seconds
    logData.removeTimer = task.spawn(function()
        task.wait(30)
        
        -- Find and remove this log
        for i, log in ipairs(activeLogs) do
            if log.serverId == serverId then
                -- Remove button if it exists
                if log.button then
                    pcall(function()
                        log.button:Destroy()
                    end)
                end
                
                -- Remove from tracking
                logButtons[serverId] = nil
                logDataStore[serverId] = nil
                table.remove(activeLogs, i)
                print("Logs Cleared!")
                break
            end
        end
    end)
end

-- WebSocket Client Implementation (from elite.lua)
local isConnecting = false  -- Prevent multiple simultaneous connection attempts
local function connectWebSocket()
    -- Prevent multiple connection attempts
    if (wsConnection and wsConnected) or isConnecting then
        return
    end
    
    isConnecting = true
    updateWSStatus(false)  -- Set to disconnected initially
    
    task.spawn(function()
        local urlsToTry = {WS_URL, WS_URL_ALT}  -- Try primary URL first, then fallback
        local currentUrlIndex = 1
        
        while true do
            local currentUrl = urlsToTry[currentUrlIndex] or WS_URL
            local success, err = pcall(function()
                -- Try different WebSocket implementations based on executor
                local ws = nil
                local wsType = nil
                
                -- Try Synapse X WebSocket (various API formats)
                if syn then
                    if syn.websocket then
                        wsType = "syn"
                        ws = syn.websocket.connect(currentUrl)
                    elseif syn.websocket_connect then
                        wsType = "syn_alt"
                        ws = syn.websocket_connect(currentUrl)
                    end
                    if ws then
                        useWebSocket = true
                    end
                
                -- Try Fluxus WebSocket
                elseif fluxus then
                    if fluxus.websocket then
                        wsType = "fluxus"
                        ws = fluxus.websocket.connect(currentUrl)
                    elseif fluxus.websocket_connect then
                        wsType = "fluxus_alt"
                        ws = fluxus.websocket_connect(currentUrl)
                    end
                    if ws then
                        useWebSocket = true
                    end
                
                -- Try Krnl WebSocket
                elseif krnl then
                    if krnl.websocket then
                        wsType = "krnl"
                        ws = krnl.websocket.connect(currentUrl)
                    elseif krnl.websocket_connect then
                        wsType = "krnl_alt"
                        ws = krnl.websocket_connect(currentUrl)
                    end
                    if ws then
                        useWebSocket = true
                    end
                
                -- Try custom WebSocket library (various formats)
                elseif _G.WebSocket then
                    wsType = "custom_global"
                    if type(_G.WebSocket) == "function" then
                        ws = _G.WebSocket(currentUrl)
                    elseif type(_G.WebSocket) == "table" and _G.WebSocket.connect then
                        ws = _G.WebSocket.connect(currentUrl)
                    elseif type(_G.WebSocket) == "table" and _G.WebSocket.new then
                        ws = _G.WebSocket.new(currentUrl)
                    end
                    if ws then
                        useWebSocket = true
                    end
                elseif WebSocket then
                    wsType = "custom"
                    if type(WebSocket) == "function" then
                        ws = WebSocket(currentUrl)
                    elseif type(WebSocket) == "table" and WebSocket.connect then
                        ws = WebSocket.connect(currentUrl)
                    elseif type(WebSocket) == "table" and WebSocket.new then
                        ws = WebSocket.new(currentUrl)
                    end
                    if ws then
                        useWebSocket = true
                    end
                
                -- Try HttpService WebSocket (if available in future Roblox versions)
                elseif HttpService.WebSocketConnect then
                    wsType = "http"
                    ws = HttpService:WebSocketConnect(currentUrl)
                    if ws then
                        useWebSocket = true
                    end
                end
                
                if not ws then
                    -- No WebSocket support available
                    useWebSocket = false
                    return false
                end
                
                -- Wait for connection to fully establish
                task.wait(1)
                
                -- Verify connection is still valid (check if it has required methods)
                if not ws or (not ws.Send and not ws.send and not ws.write) then
                    return false
                end
                
                wsConnection = ws
                wsConnected = true
                wsReconnectDelay = 2  -- Reset delay on successful connection
                isConnecting = false  -- Connection established
                
                updateWSStatus(true)  -- Update GUI to connected
                print("[WebSocket] ‚úÖ Connected successfully - Stable connection established")
                
                -- Register client (try different send methods)
                -- SocketIO uses Engine.IO protocol, so we need to send in format: 42["register",{data}]
                -- Construct SocketIO message safely to avoid bracket parsing issues
                local registerData = {client_id = CLIENT_ID}
                local registerArray = {"register", registerData}
                local registerJson = HttpService:JSONEncode(registerArray)
                -- Use string concatenation to avoid any parsing issues - ensure it's a string
                local registerJsonStr = tostring(registerJson)
                local socketIORegisterMsg = "42" .. registerJsonStr
                
                -- Also try raw JSON as fallback
                local registerMsg = HttpService:JSONEncode({
                    type = "register",
                    client_id = CLIENT_ID
                })
                
                local sendSuccess = false
                if ws.Send then
                    -- Try SocketIO format first
                    sendSuccess = pcall(function() ws:Send(socketIORegisterMsg) end)
                    if not sendSuccess then
                        -- Fallback to raw JSON
                        sendSuccess = pcall(function() ws:Send(registerMsg) end)
                    end
                elseif ws.send then
                    sendSuccess = pcall(function() ws:send(socketIORegisterMsg) end)
                    if not sendSuccess then
                        sendSuccess = pcall(function() ws:send(registerMsg) end)
                    end
                elseif ws.write then
                    sendSuccess = pcall(function() ws:write(socketIORegisterMsg) end)
                    if not sendSuccess then
                        sendSuccess = pcall(function() ws:write(registerMsg) end)
                    end
                end
                
                if not sendSuccess then
                    warn("[WebSocket] Failed to send registration, but keeping connection alive")
                    -- Don't disconnect - connection might still work for receiving
                end
                
                -- Wait for registration confirmation
                task.wait(2)
                
                -- Set up message handler (try different event names)
                local messageHandler = function(message)
                    -- Handle SocketIO Engine.IO protocol messages
                    -- Format: 40 (connect), 41 (disconnect), 42["event", data], 43[ackId, data], etc.
                    local processed = false
                    
                    -- Check if it's a SocketIO message (starts with number)
                    if type(message) == "string" and string.match(message, "^%d+") then
                        local msgType = tonumber(string.match(message, "^(%d+)"))
                        
                        if msgType == 0 then
                            -- Engine.IO open packet - contains session info
                            processed = true
                        elseif msgType == 1 then
                            -- Engine.IO close packet - DO NOT disconnect, this is normal protocol
                            print("[WebSocket] ‚ÑπÔ∏è Received close packet (normal protocol message)")
                            processed = true
                        elseif msgType == 2 then
                            -- Server ping - must respond with pong (3)
                            local pongSuccess = pcall(function()
                                local pongMsg = "3"
                                if wsConnection and wsConnected then
                                    if wsConnection.Send then
                                        wsConnection:Send(pongMsg)
                                    elseif wsConnection.send then
                                        wsConnection:send(pongMsg)
                                    elseif wsConnection.write then
                                        wsConnection:write(pongMsg)
                                    end
                                end
                            end)
                            if pongSuccess then
                                -- Successfully responded to ping
                                processed = true
                            else
                                warn("[WebSocket] Failed to respond to server ping")
                                processed = true
                            end
                        elseif msgType == 3 then
                            -- Server pong response (to our ping)
                            processed = true
                        elseif msgType == 40 then
                            -- SocketIO connect confirmation
                            processed = true
                        elseif msgType == 42 then
                            -- SocketIO event message: 42["event_name", data]
                            local eventData = string.match(message, "^42(.+)")
                            if eventData then
                                local decodeSuccess, eventArray = pcall(function()
                                    return HttpService:JSONDecode(eventData)
                                end)
                                
                                if decodeSuccess and type(eventArray) == "table" and #eventArray >= 2 then
                                    local eventName = eventArray[1]
                                    local data = eventArray[2]
                                    
                                    if eventName == "registered" then
                                        print("[WebSocket] ‚úÖ Registered successfully - Connection stable")
                                        processed = true
                                    elseif eventName == "job" then
                                        -- Process job
                                        if data and data.has_job then
                                            -- CRITICAL: Don't process ANY jobs until client load time is confirmed
                                            if clientLoadedTime == 0 or not clientLoadedSuccess then
                                                print("[WebSocket] ‚ö†Ô∏è Rejecting job - client load time not confirmed yet")
                                                processed = true
                                                -- Skip this job completely
                                            else
                                                -- CRITICAL: Filter out old jobs created before client loaded
                                                local jobCreatedTime = tonumber(data.created_time) or 0
                                                
                                                -- Both times must be valid Unix timestamps
                                                if jobCreatedTime > 0 and clientLoadedTime > 0 then
                                                    -- Skip if job was created BEFORE client loaded
                                                    if jobCreatedTime < clientLoadedTime then
                                                        print("[WebSocket] ‚ö†Ô∏è REJECTING OLD JOB - Created:", jobCreatedTime, "Client loaded:", clientLoadedTime, "Diff:", (clientLoadedTime - jobCreatedTime), "seconds")
                                                        -- Skip this job - don't add to pendingJobs
                                                        processed = true
                                                    else
                                                        -- Job is newer than client load time - accept it
                                                        print("[WebSocket] ‚úÖ ACCEPTING JOB - Created:", jobCreatedTime, "Client loaded:", clientLoadedTime, "Diff:", (jobCreatedTime - clientLoadedTime), "seconds")
                                                        
                                                        -- Ensure pet_value is a number
                                                        if data.pet_value then
                                                            data.pet_value = tonumber(data.pet_value) or 0
                                                        else
                                                            data.pet_value = 0
                                                        end
                                                        
                                                        -- Handle null thumbnail
                                                        if data.pet_thumbnail == "null" or data.pet_thumbnail == "" then
                                                            data.pet_thumbnail = nil
                                                        end
                                                        
                                                        -- Handle pet_value_formatted
                                                        if not data.pet_value_formatted or data.pet_value_formatted == "" then
                                                            data.pet_value_formatted = nil
                                                        end
                                                        
                                                        -- Add to pending jobs queue (only if not old)
                                                        table.insert(pendingJobs, data)
                                                        print("[WebSocket] ‚úÖ Job queued:", data.pet_name or "Unknown")
                                                    end
                                                else
                                                    -- Invalid timestamps - reject to be safe
                                                    warn("[WebSocket] ‚ö†Ô∏è Rejecting job - invalid timestamps (job:", jobCreatedTime, "client:", clientLoadedTime, ")")
                                                    processed = true
                                                end
                                            end
                                        end
                                        processed = true
                                    elseif eventName == "pong" then
                                        processed = true
                                    elseif eventName == "error" then
                                        processed = true
                                    end
                                end
                            end
                        elseif msgType == 41 then
                            -- SocketIO disconnect - DO NOT disconnect, this is normal protocol
                            print("[WebSocket] ‚ÑπÔ∏è Received disconnect packet (normal protocol message)")
                            processed = true
                        end
                    end
                    
                    -- Fallback to raw JSON parsing if not SocketIO format
                    if not processed then
                        local decodeSuccess, data = pcall(function()
                            return HttpService:JSONDecode(message)
                        end)
                        
                        if decodeSuccess and data then
                            if data.type == "registered" then
                                print("[WebSocket] ‚úÖ Registered successfully - Connection stable")
                            elseif data.type == "job" then
                                -- Process job
                                if data.has_job then
                                    -- CRITICAL: Don't process ANY jobs until client load time is confirmed
                                    if clientLoadedTime == 0 or not clientLoadedSuccess then
                                        print("[WebSocket] ‚ö†Ô∏è Rejecting job (JSON) - client load time not confirmed yet")
                                        -- Skip this job completely
                                    else
                                        -- CRITICAL: Filter out old jobs created before client loaded
                                        local jobCreatedTime = tonumber(data.created_time) or 0
                                        
                                        -- Both times must be valid Unix timestamps
                                        if jobCreatedTime > 0 and clientLoadedTime > 0 then
                                            -- Skip if job was created BEFORE client loaded
                                            if jobCreatedTime < clientLoadedTime then
                                                print("[WebSocket] ‚ö†Ô∏è REJECTING OLD JOB (JSON) - Created:", jobCreatedTime, "Client loaded:", clientLoadedTime, "Diff:", (clientLoadedTime - jobCreatedTime), "seconds")
                                                -- Skip this job
                                            else
                                                -- Job is newer than client load time - accept it
                                                print("[WebSocket] ‚úÖ ACCEPTING JOB (JSON) - Created:", jobCreatedTime, "Client loaded:", clientLoadedTime, "Diff:", (jobCreatedTime - clientLoadedTime), "seconds")
                                                
                                                -- Ensure pet_value is a number
                                                if data.pet_value then
                                                    data.pet_value = tonumber(data.pet_value) or 0
                                                else
                                                    data.pet_value = 0
                                                end
                                                
                                                -- Handle null thumbnail
                                                if data.pet_thumbnail == "null" or data.pet_thumbnail == "" then
                                                    data.pet_thumbnail = nil
                                                end
                                                
                                                -- Handle pet_value_formatted
                                                if not data.pet_value_formatted or data.pet_value_formatted == "" then
                                                    data.pet_value_formatted = nil
                                                end
                                                
                                                -- Add to pending jobs queue (only if not old)
                                                table.insert(pendingJobs, data)
                                                print("[WebSocket] ‚úÖ Job queued (JSON):", data.pet_name or "Unknown")
                                            end
                                        else
                                            -- Invalid timestamps - reject to be safe
                                            warn("[WebSocket] ‚ö†Ô∏è Rejecting job (JSON) - invalid timestamps (job:", jobCreatedTime, "client:", clientLoadedTime, ")")
                                        end
                                    end
                                end
                            elseif data.type == "pong" then
                                -- Heartbeat response
                            elseif data.type == "error" then
                                -- Error received
                            end
                        end
                    end
                end
                
                -- Try different event connection methods
                if ws.OnMessage then
                    ws.OnMessage:Connect(messageHandler)
                elseif ws.onMessage then
                    ws.onMessage:Connect(messageHandler)
                elseif ws.on then
                    ws.on("message", messageHandler)
                elseif ws.addEventListener then
                    ws.addEventListener("message", messageHandler)
                end
                
                -- DON'T set up close handler - let connection stay persistent
                -- Close events are often spurious and don't mean the connection is actually dead
                -- Connection will NEVER auto-disconnect
                print("[WebSocket] ‚úÖ Connection fully established - PERMANENT CONNECTION")
                print("[WebSocket] ‚ÑπÔ∏è Close handler disabled - Connection is persistent")
                print("[WebSocket] ‚ÑπÔ∏è Connection will NEVER auto-disconnect")
                
                -- Error handler disabled - errors don't affect connection
                -- Most WebSocket "errors" are just informational and shouldn't cause disconnections
                print("[WebSocket] ‚ÑπÔ∏è Error handler disabled - connection is fault-tolerant")
                
                -- Send periodic ping (SocketIO format: 2 = ping, server responds with 3 = pong)
                -- Pings are informational only - will NEVER disconnect
                task.spawn(function()
                    local failedPings = 0
                    while wsConnected and wsConnection do
                        task.wait(45) -- Send ping every 45 seconds
                        if wsConnection and wsConnected then
                            local success = pcall(function()
                                -- SocketIO ping format is just "2"
                                local pingMsg = "2"
                                if wsConnection.Send then
                                    wsConnection:Send(pingMsg)
                                elseif wsConnection.send then
                                    wsConnection:send(pingMsg)
                                elseif wsConnection.write then
                                    wsConnection:write(pingMsg)
                                end
                            end)
                            
                            if not success then
                                failedPings = failedPings + 1
                                -- Just log, never disconnect
                                if failedPings % 10 == 0 then
                                    print("[WebSocket] ‚ÑπÔ∏è " .. failedPings .. " pings failed, but connection persists")
                                end
                            else
                                if failedPings > 0 then
                                    print("[WebSocket] ‚úÖ Ping recovered after " .. failedPings .. " failures")
                                end
                                failedPings = 0  -- Reset counter on successful ping
                            end
                        else
                            break
                        end
                    end
                end)
                
                return true
            end)
            
            if not success then
                -- Error occurred during connection attempt
                local errorMsg = tostring(err) or "Unknown error"
                wsConnected = false
                wsConnection = nil
                useWebSocket = false
                updateWSStatus(false)  -- Update GUI to disconnected
                
                -- Check if it's a "not supported" error vs connection error
                if string.find(errorMsg:lower(), "not supported") or string.find(errorMsg:lower(), "no websocket") then
                    isConnecting = false
                    break -- Exit retry loop, use HTTP polling
                end
                
                -- Try next URL if available
                if currentUrlIndex < #urlsToTry then
                    currentUrlIndex = currentUrlIndex + 1
                    task.wait(1) -- Short delay before trying next URL
                else
                    -- Reset to first URL and wait before retrying
                    currentUrlIndex = 1
                    isConnecting = false  -- Allow future connection attempts
                    task.wait(wsReconnectDelay)
                    
                    -- Exponential backoff
                    wsReconnectDelay = math.min(wsReconnectDelay * 2, maxWsReconnectDelay)
                end
            elseif err == false then
                -- WebSocket not supported, use HTTP polling
                useWebSocket = false
                isConnecting = false
                break
            else
                -- Connection successful, break out of retry loop
                isConnecting = false
                break
            end
        end
        
        isConnecting = false  -- Ensure flag is cleared when function ends
    end)
end

-- Initialize WebSocket connection (matching priopremium.lua exactly)
-- CRITICAL: Wait for /client_loaded to complete first
task.spawn(function()
    -- Wait for client to fully initialize
    task.wait(2)
    
    -- Verify clientLoadedTime is set (should already be set since markClientAsLoaded() is blocking)
    if clientLoadedTime == 0 or not clientLoadedSuccess then
        warn("[WebSocket] ‚ö†Ô∏è Client load time not set properly, waiting...")
        -- Wait a bit more for it to be set
        local maxWait = 3
        local waited = 0
        while (clientLoadedTime == 0 or not clientLoadedSuccess) and waited < maxWait do
            task.wait(0.1)
            waited = waited + 0.1
        end
        
        if clientLoadedTime == 0 then
            warn("[WebSocket] ‚ö†Ô∏è Client load time still not set, connecting anyway (may receive old jobs)")
        else
            print("[WebSocket] ‚úÖ Client load time confirmed:", clientLoadedTime, "- Safe to connect")
        end
    else
        print("[WebSocket] ‚úÖ Client load time confirmed:", clientLoadedTime, "- Safe to connect")
    end
    
    print("[WebSocket] üîå Initiating persistent WebSocket connection...")
    connectWebSocket()
end)

-- Background WebSocket monitor - Safety net for reconnection only (from elite.lua)
task.spawn(function()
    while true do
        task.wait(120) -- Check every 2 minutes (minimal monitoring)
        if not wsConnected and not isConnecting then
            print("[WebSocket Monitor] üîÑ External disconnection detected, reconnecting...")
            updateWSStatus(false)
            connectWebSocket()
        end
    end
end)

-- Check for job (WebSocket or HTTP fallback)
local function checkForJob()
    -- CRITICAL: Don't check for jobs until client has been marked as loaded
    -- This prevents receiving old jobs from before the client loaded
    if clientLoadedTime == 0 or not clientLoadedSuccess then
        -- Client hasn't loaded yet, return no job
        print("[Job Check] ‚ö†Ô∏è Skipping job check - client load time not confirmed")
        return {has_job = false}
    end
    
    -- Check pending jobs from WebSocket first
    if #pendingJobs > 0 then
        -- Filter out any old jobs that might have slipped through
        local validJobs = {}
        local removedCount = 0
        for i, job in ipairs(pendingJobs) do
            local jobCreatedTime = tonumber(job.created_time) or 0
            if jobCreatedTime > 0 and clientLoadedTime > 0 then
                -- Only keep jobs created AFTER client loaded
                if jobCreatedTime >= clientLoadedTime then
                    table.insert(validJobs, job)
                else
                    removedCount = removedCount + 1
                    print("[Job Filter] ‚ö†Ô∏è Removing old job from queue (created:", jobCreatedTime, "client loaded:", clientLoadedTime, "diff:", (clientLoadedTime - jobCreatedTime), "seconds)")
                end
            else
                -- Invalid timestamp - reject to be safe
                removedCount = removedCount + 1
                warn("[Job Filter] ‚ö†Ô∏è Removing job with invalid timestamp")
            end
        end
        
        -- Replace global pendingJobs queue with filtered jobs
        if removedCount > 0 then
            print("[Job Filter] üßπ Removed", removedCount, "old/invalid jobs from queue")
        end
        
        -- Clear and repopulate pendingJobs
        pendingJobs = {}
        for _, job in ipairs(validJobs) do
            table.insert(pendingJobs, job)
        end
        
        -- Return first valid job
        if #pendingJobs > 0 then
            local job = table.remove(pendingJobs, 1)
            print("[Job Filter] ‚úÖ Returning job (created:", job.created_time, "client loaded:", clientLoadedTime, ")")
            return job
        end
    end
    
    -- Always check HTTP as backup even if WebSocket is connected
    -- This ensures we don't miss jobs if WebSocket has issues
    local url = API_URL .. "/get_job?client_id=" .. HttpService:UrlEncode(CLIENT_ID)
    local success, result = pcall(function()
        return game:HttpGet(url)
    end)
    
    if not success then
    return {has_job = false}
    end
    
    if not result or result == "" then
        return {has_job = false}
    end
    
    local decodeSuccess, jobData = pcall(function()
        return HttpService:JSONDecode(result)
    end)
    
    if not decodeSuccess then
        return {has_job = false}
    end
    
    if not jobData then
        return {has_job = false}
    end
    
    -- Ensure pet_value is a number (handle float values)
    if jobData.pet_value then
        jobData.pet_value = tonumber(jobData.pet_value) or 0
    else
        jobData.pet_value = 0
    end
    
    -- Handle null thumbnail (convert to nil)
    if jobData.pet_thumbnail == "null" or jobData.pet_thumbnail == "" then
        jobData.pet_thumbnail = nil
    end
    
    -- Handle pet_value_formatted (use API formatted value if available)
    if not jobData.pet_value_formatted or jobData.pet_value_formatted == "" then
        jobData.pet_value_formatted = nil
    end
    
    return jobData
end

-- Helper function to remove brackets from pet name (e.g., "[Mutation] Pet Name" -> "Pet Name")
local function removeBracketsFromPetName(petName)
    if not petName then return nil end
    -- Remove brackets like [Mutation], [Galaxy], etc. from the beginning
    local cleaned = string.gsub(petName, "^%s*%[.-%]%s*", "") -- Remove [anything] at start
    -- Also trim whitespace
    cleaned = string.gsub(cleaned, "^%s*(.-)%s*$", "%1")
    return cleaned
end

-- Check if pet is a priority pet (user-selected in GUI) - from elite.lua
local function isPriorityPet(petName)
    if not petName then return false end
    if not Settings.PriorityPets or type(Settings.PriorityPets) ~= "table" then
        Settings.PriorityPets = {}
        return false
    end
    -- Remove brackets before checking (e.g., "[Mutation] Pet Name" -> "Pet Name")
    local cleanedName = removeBracketsFromPetName(petName)
    if not cleanedName then return false end
    -- Check if user selected it in GUI (not just if it's in the priority list)
    return Settings.PriorityPets[cleanedName] == true
end

-- Check if pet is blacklisted - from elite.lua
local function isPetBlacklisted(petName)
    if not petName then return false end
    if not Settings.BlacklistedPets or type(Settings.BlacklistedPets) ~= "table" then
        Settings.BlacklistedPets = {}
        return false
    end
    -- Remove brackets before checking (e.g., "[Mutation] Pet Name" -> "Pet Name")
    local cleanedName = removeBracketsFromPetName(petName)
    if not cleanedName then return false end
    local cleanNameLower = string.lower(cleanedName)
    for blacklistedName, isBlacklisted in pairs(Settings.BlacklistedPets) do
        if isBlacklisted == true then
            local blacklistedNameLower = string.lower(tostring(blacklistedName))
            if cleanNameLower == blacklistedNameLower then
            return true
            end
        end
    end
    return false
end

-- Dynamic check interval (from elite.lua)
local function getDynamicCheckInterval()
    -- Base interval from settings
    local baseInterval = Settings.CheckInterval or 2
    return baseInterval
end

-- Main loop (matching orig.lua exactly)
local function startMainLoop(gui)
    task.spawn(function()
        while true do
            -- Collect all available jobs first, prioritizing priority pets
            local priorityJobs = {}
            local normalJobs = {}
            local maxQuickChecks = 5 -- Check up to 5 times quickly if jobs are found
            
            -- Collect jobs without processing them immediately
            for quickCheck = 1, maxQuickChecks do
                local jobData = checkForJob()
                
                if jobData.has_job and jobData.server_id then
                        -- Ensure pet_value is a number
                        local petValue = tonumber(jobData.pet_value) or 0
                        local petName = jobData.pet_name or "Unknown"
                    
                    -- CHECK BLACKLIST FIRST - Blacklisted pets are ALWAYS rejected, even if priority
                    if isPetBlacklisted(petName) then
                        print(string.format("[Job Rejected] üö´ Pet %s is BLACKLISTED (rejecting regardless of priority)", petName))
                        clearJob(jobData.server_id)
                        -- Skip to next job - don't add to any list
                        -- Continue to next iteration
                    else
                        local isPriority = isPriorityPet(petName)
                        
                        -- Ensure Settings.MinValue is a number
                        local minValue = tonumber(Settings.MinValue) or 100000000
                        
                        -- Debug logging
                        print(string.format("[Job Received] Pet: %s | Value: %.0f | MinValue: %.0f | Priority: %s | Server: %s", 
                            petName, petValue, minValue, tostring(isPriority), jobData.server_id))
                        
                        -- Priority pets bypass processed servers and value checks, but NOT blacklist (already checked above)
                        if isPriority then
                            -- Add to priority jobs list (blacklist already checked and passed)
                            print(string.format("[Job Accepted] ‚≠ê PRIORITY PET: %s", petName))
                            table.insert(priorityJobs, jobData)
                        elseif not processedServers[jobData.server_id] then
                            -- For normal pets, apply value filter (blacklist already checked above)
                            if petValue < minValue then
                                print(string.format("[Job Rejected] Pet %s value %.0f is below minimum %.0f", 
                                    petName, petValue, minValue))
                            clearJob(jobData.server_id)
                            else
                                -- Add to normal jobs list
                                table.insert(normalJobs, jobData)
                            end
                        else
                            -- Normal pet already processed
                            clearJob(jobData.server_id)
                        end
                    end
                    
                    -- If we found a job, check again quickly for more (small delay between checks)
                    if quickCheck < maxQuickChecks then
                        task.wait(0.1) -- Small delay to catch multiple simultaneous jobs
                    end
                else
                    -- No job found, break out of quick check loop
                    break
                end
            end
            
            -- Process priority jobs first - join immediately if priority pets exist
            if #priorityJobs > 0 then
                -- Add all priority logs first
                for _, jobData in ipairs(priorityJobs) do
                    local petValue = tonumber(jobData.pet_value) or 0
                    local petName = jobData.pet_name or "Unknown"
                            print(string.format("[Job Accepted] ‚≠ê PRIORITY PET: %s (Value: %.0f)", petName, petValue))
                            addLog(petName, petValue, jobData.server_id, jobData.pet_thumbnail, gui, jobData.pet_value_formatted, true)
                end
                            
                            if Settings.Enabled then
                    -- If currently joining a normal pet, stop and join priority instead
                                if currentlyJoining then
                        print("[Auto-Join] ‚ö†Ô∏è Priority pet detected! Canceling current join for priority")
                                    stopJoining = true
                        -- Wait for current join to stop
                        while currentlyJoining do
                            task.wait(0.1)
                        end
                        task.wait(0.2) -- Small delay after stopping
                    end
                    
                    -- Join the first priority pet immediately
                    local firstPriorityJob = priorityJobs[1]
                    local priorityPetName = firstPriorityJob.pet_name or "Unknown"
                    print(string.format("[Auto-Join] üöÄ Starting join for priority pet %s (from %d priority pets)", priorityPetName, #priorityJobs))
                    joinServerWithRetries(firstPriorityJob.server_id, gui, false)
                    
                    -- Clear other priority jobs (we only join the first one)
                    for i = 2, #priorityJobs do
                        local otherJob = priorityJobs[i]
                        local otherPetName = otherJob.pet_name or "Unknown"
                        print(string.format("[Auto-Join] ‚ö†Ô∏è Skipping other priority pet %s (already joining first priority)", otherPetName))
                        clearJob(otherJob.server_id)
                    end
                    
                    -- Wait for join to complete
                    while currentlyJoining do
                        task.wait(0.1)
                    end
                    task.wait(0.2) -- Small delay after join completes
                else
                    -- Clear all priority jobs if not auto-joining
                    for _, jobData in ipairs(priorityJobs) do
                                clearJob(jobData.server_id)
                            end
                end
            end
            
            -- Process normal jobs only if no priority jobs were found
            if #priorityJobs == 0 then
                for _, jobData in ipairs(normalJobs) do
                    local petValue = tonumber(jobData.pet_value) or 0
                    local petName = jobData.pet_name or "Unknown"
                    
                            print(string.format("[Job Accepted] ‚úÖ Pet %s (Value: %.0f)", petName, petValue))
                            addLog(petName, petValue, jobData.server_id, jobData.pet_thumbnail, gui, jobData.pet_value_formatted, false)
                            
                            if Settings.Enabled then
                        -- Only join if not already joining
                                if not currentlyJoining then
                                    print(string.format("[Auto-Join] üöÄ Starting join for pet %s", petName))
                                    joinServerWithRetries(jobData.server_id, gui, false)
                            
                            -- Wait for join to complete before processing next normal job
                            while currentlyJoining do
                                task.wait(0.1)
                            end
                            task.wait(0.2) -- Small delay after join completes
                        else
                            print(string.format("[Auto-Join] ‚ö†Ô∏è Already joining, skipping %s", petName))
                                    -- Clear job if we can't join right now
                                    clearJob(jobData.server_id)
                                end
                            else
                                -- Clear job after adding log if not auto-joining
                                clearJob(jobData.server_id)
                            end
                        end
                    else
                -- If we processed priority jobs, clear normal jobs (priority takes precedence)
                for _, jobData in ipairs(normalJobs) do
                    local petName = jobData.pet_name or "Unknown"
                    print(string.format("[Auto-Join] ‚ö†Ô∏è Priority pets found, skipping normal pet %s", petName))
                        clearJob(jobData.server_id)
                end
            end
            
            -- Dynamic interval wait based on FPS
            local dynamicInterval = getDynamicCheckInterval()
            task.wait(dynamicInterval)
        end
    end)
end

-- Start main loop
startMainLoop(nil) -- Pass nil for gui since Aether Elite doesn't have StopButton/StatusLabel

-- Initialize ESP System
task.spawn(function()
    task.wait(2) -- Wait for game to fully load
    initializeESP()
end)



